/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from CombinedDomains.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#include "config.h"
#include "InspectorBackendDispatchers.h"

#include <inspector/InspectorFrontendChannel.h>
#include <inspector/InspectorValues.h>
#include <wtf/text/CString.h>

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
#include "InspectorAlternateBackendDispatchers.h"
#endif

namespace Inspector {

ApplicationCacheBackendDispatcherHandler::~ApplicationCacheBackendDispatcherHandler() { }
CSSBackendDispatcherHandler::~CSSBackendDispatcherHandler() { }
ConsoleBackendDispatcherHandler::~ConsoleBackendDispatcherHandler() { }
DOMBackendDispatcherHandler::~DOMBackendDispatcherHandler() { }
DOMDebuggerBackendDispatcherHandler::~DOMDebuggerBackendDispatcherHandler() { }
DOMStorageBackendDispatcherHandler::~DOMStorageBackendDispatcherHandler() { }
DatabaseBackendDispatcherHandler::~DatabaseBackendDispatcherHandler() { }
DebuggerBackendDispatcherHandler::~DebuggerBackendDispatcherHandler() { }
InspectorBackendDispatcherHandler::~InspectorBackendDispatcherHandler() { }
LayerTreeBackendDispatcherHandler::~LayerTreeBackendDispatcherHandler() { }
NetworkBackendDispatcherHandler::~NetworkBackendDispatcherHandler() { }
PageBackendDispatcherHandler::~PageBackendDispatcherHandler() { }
RuntimeBackendDispatcherHandler::~RuntimeBackendDispatcherHandler() { }
TimelineBackendDispatcherHandler::~TimelineBackendDispatcherHandler() { }
WorkerBackendDispatcherHandler::~WorkerBackendDispatcherHandler() { }

Ref<ApplicationCacheBackendDispatcher> ApplicationCacheBackendDispatcher::create(BackendDispatcher* backendDispatcher, ApplicationCacheBackendDispatcherHandler* agent)
{
    return adoptRef(*new ApplicationCacheBackendDispatcher(*backendDispatcher, agent));
}

ApplicationCacheBackendDispatcher::ApplicationCacheBackendDispatcher(BackendDispatcher& backendDispatcher, ApplicationCacheBackendDispatcherHandler* agent)
    : SupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    , m_alternateDispatcher(nullptr)
#endif
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("ApplicationCache"), this);
}

void ApplicationCacheBackendDispatcher::dispatch(long callId, const String& method, Ref<InspectorObject>&& message)
{
    Ref<ApplicationCacheBackendDispatcher> protect(*this);

    if (method == "getFramesWithManifests")
        getFramesWithManifests(callId, message);
    else if (method == "enable")
        enable(callId, message);
    else if (method == "getManifestForFrame")
        getManifestForFrame(callId, message);
    else if (method == "getApplicationCacheForFrame")
        getApplicationCacheForFrame(callId, message);
    else
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::MethodNotFound, makeString('\'', "ApplicationCache", '.', method, "' was not found"));
}

void ApplicationCacheBackendDispatcher::getFramesWithManifests(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getFramesWithManifests(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::ApplicationCache::FrameWithManifest>> out_frameIds;
    m_agent->getFramesWithManifests(error, out_frameIds);

    if (!error.length())
        result->setArray(ASCIILiteral("frameIds"), out_frameIds);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void ApplicationCacheBackendDispatcher::enable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->enable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->enable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void ApplicationCacheBackendDispatcher::getManifestForFrame(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_frameId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("frameId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "ApplicationCache.getManifestForFrame");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getManifestForFrame(callId, in_frameId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    String out_manifestURL;
    m_agent->getManifestForFrame(error, in_frameId, &out_manifestURL);

    if (!error.length())
        result->setString(ASCIILiteral("manifestURL"), out_manifestURL);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void ApplicationCacheBackendDispatcher::getApplicationCacheForFrame(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_frameId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("frameId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "ApplicationCache.getApplicationCacheForFrame");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getApplicationCacheForFrame(callId, in_frameId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::ApplicationCache::ApplicationCache> out_applicationCache;
    m_agent->getApplicationCacheForFrame(error, in_frameId, out_applicationCache);

    if (!error.length())
        result->setObject(ASCIILiteral("applicationCache"), out_applicationCache);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

Ref<CSSBackendDispatcher> CSSBackendDispatcher::create(BackendDispatcher* backendDispatcher, CSSBackendDispatcherHandler* agent)
{
    return adoptRef(*new CSSBackendDispatcher(*backendDispatcher, agent));
}

CSSBackendDispatcher::CSSBackendDispatcher(BackendDispatcher& backendDispatcher, CSSBackendDispatcherHandler* agent)
    : SupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    , m_alternateDispatcher(nullptr)
#endif
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("CSS"), this);
}

void CSSBackendDispatcher::dispatch(long callId, const String& method, Ref<InspectorObject>&& message)
{
    Ref<CSSBackendDispatcher> protect(*this);

    typedef void (CSSBackendDispatcher::*CallHandler)(long callId, const InspectorObject& message);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEPRECATED_DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, ());
    if (dispatchMap.isEmpty()) {
        static const struct MethodTable {
            const char* name;
            CallHandler handler;
        } commands[] = {
            { "enable", &CSSBackendDispatcher::enable },
            { "disable", &CSSBackendDispatcher::disable },
            { "getMatchedStylesForNode", &CSSBackendDispatcher::getMatchedStylesForNode },
            { "getInlineStylesForNode", &CSSBackendDispatcher::getInlineStylesForNode },
            { "getComputedStyleForNode", &CSSBackendDispatcher::getComputedStyleForNode },
            { "getAllStyleSheets", &CSSBackendDispatcher::getAllStyleSheets },
            { "getStyleSheet", &CSSBackendDispatcher::getStyleSheet },
            { "getStyleSheetText", &CSSBackendDispatcher::getStyleSheetText },
            { "setStyleSheetText", &CSSBackendDispatcher::setStyleSheetText },
            { "setStyleText", &CSSBackendDispatcher::setStyleText },
            { "setRuleSelector", &CSSBackendDispatcher::setRuleSelector },
            { "addRule", &CSSBackendDispatcher::addRule },
            { "getSupportedCSSProperties", &CSSBackendDispatcher::getSupportedCSSProperties },
            { "getSupportedSystemFontFamilyNames", &CSSBackendDispatcher::getSupportedSystemFontFamilyNames },
            { "forcePseudoState", &CSSBackendDispatcher::forcePseudoState },
            { "getNamedFlowCollection", &CSSBackendDispatcher::getNamedFlowCollection },
        };
        size_t length = WTF_ARRAY_LENGTH(commands);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commands[i].name, commands[i].handler);
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::MethodNotFound, makeString('\'', "CSS", '.', method, "' was not found"));
        return;
    }

    ((*this).*it->value)(callId, message.get());
}

void CSSBackendDispatcher::enable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->enable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->enable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void CSSBackendDispatcher::disable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->disable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->disable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void CSSBackendDispatcher::getMatchedStylesForNode(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    bool opt_in_includePseudo_valueFound = false;
    bool opt_in_includePseudo = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("includePseudo"), &opt_in_includePseudo_valueFound, protocolErrors.get());
    bool opt_in_includeInherited_valueFound = false;
    bool opt_in_includeInherited = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("includeInherited"), &opt_in_includeInherited_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.getMatchedStylesForNode");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getMatchedStylesForNode(callId, in_nodeId, opt_in_includePseudo_valueFound ? &opt_in_includePseudo : nullptr, opt_in_includeInherited_valueFound ? &opt_in_includeInherited : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::RuleMatch>> out_matchedCSSRules;
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::PseudoIdMatches>> out_pseudoElements;
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::InheritedStyleEntry>> out_inherited;
    m_agent->getMatchedStylesForNode(error, in_nodeId, opt_in_includePseudo_valueFound ? &opt_in_includePseudo : nullptr, opt_in_includeInherited_valueFound ? &opt_in_includeInherited : nullptr, out_matchedCSSRules, out_pseudoElements, out_inherited);

    if (!error.length()) {
        if (out_matchedCSSRules)
            result->setArray(ASCIILiteral("matchedCSSRules"), out_matchedCSSRules);
        if (out_pseudoElements)
            result->setArray(ASCIILiteral("pseudoElements"), out_pseudoElements);
        if (out_inherited)
            result->setArray(ASCIILiteral("inherited"), out_inherited);
    }
    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void CSSBackendDispatcher::getInlineStylesForNode(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.getInlineStylesForNode");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getInlineStylesForNode(callId, in_nodeId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::CSS::CSSStyle> out_inlineStyle;
    RefPtr<Inspector::Protocol::CSS::CSSStyle> out_attributesStyle;
    m_agent->getInlineStylesForNode(error, in_nodeId, out_inlineStyle, out_attributesStyle);

    if (!error.length()) {
        if (out_inlineStyle)
            result->setObject(ASCIILiteral("inlineStyle"), out_inlineStyle);
        if (out_attributesStyle)
            result->setObject(ASCIILiteral("attributesStyle"), out_attributesStyle);
    }
    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void CSSBackendDispatcher::getComputedStyleForNode(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.getComputedStyleForNode");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getComputedStyleForNode(callId, in_nodeId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSComputedStyleProperty>> out_computedStyle;
    m_agent->getComputedStyleForNode(error, in_nodeId, out_computedStyle);

    if (!error.length())
        result->setArray(ASCIILiteral("computedStyle"), out_computedStyle);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void CSSBackendDispatcher::getAllStyleSheets(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getAllStyleSheets(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSStyleSheetHeader>> out_headers;
    m_agent->getAllStyleSheets(error, out_headers);

    if (!error.length())
        result->setArray(ASCIILiteral("headers"), out_headers);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void CSSBackendDispatcher::getStyleSheet(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_styleSheetId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("styleSheetId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.getStyleSheet");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getStyleSheet(callId, in_styleSheetId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::CSS::CSSStyleSheetBody> out_styleSheet;
    m_agent->getStyleSheet(error, in_styleSheetId, out_styleSheet);

    if (!error.length())
        result->setObject(ASCIILiteral("styleSheet"), out_styleSheet);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void CSSBackendDispatcher::getStyleSheetText(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_styleSheetId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("styleSheetId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.getStyleSheetText");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getStyleSheetText(callId, in_styleSheetId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    String out_text;
    m_agent->getStyleSheetText(error, in_styleSheetId, &out_text);

    if (!error.length())
        result->setString(ASCIILiteral("text"), out_text);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void CSSBackendDispatcher::setStyleSheetText(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_styleSheetId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("styleSheetId"), nullptr, protocolErrors.get());
    String in_text = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("text"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.setStyleSheetText");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setStyleSheetText(callId, in_styleSheetId, in_text);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setStyleSheetText(error, in_styleSheetId, in_text);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void CSSBackendDispatcher::setStyleText(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    RefPtr<Inspector::InspectorObject> in_styleId = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("styleId"), nullptr, protocolErrors.get());
    String in_text = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("text"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.setStyleText");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setStyleText(callId, *in_styleId, in_text);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::CSS::CSSStyle> out_style;
    m_agent->setStyleText(error, *in_styleId, in_text, out_style);

    if (!error.length())
        result->setObject(ASCIILiteral("style"), out_style);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void CSSBackendDispatcher::setRuleSelector(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    RefPtr<Inspector::InspectorObject> in_ruleId = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("ruleId"), nullptr, protocolErrors.get());
    String in_selector = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("selector"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.setRuleSelector");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setRuleSelector(callId, *in_ruleId, in_selector);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::CSS::CSSRule> out_rule;
    m_agent->setRuleSelector(error, *in_ruleId, in_selector, out_rule);

    if (!error.length())
        result->setObject(ASCIILiteral("rule"), out_rule);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void CSSBackendDispatcher::addRule(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_contextNodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("contextNodeId"), nullptr, protocolErrors.get());
    String in_selector = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("selector"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.addRule");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->addRule(callId, in_contextNodeId, in_selector);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::CSS::CSSRule> out_rule;
    m_agent->addRule(error, in_contextNodeId, in_selector, out_rule);

    if (!error.length())
        result->setObject(ASCIILiteral("rule"), out_rule);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void CSSBackendDispatcher::getSupportedCSSProperties(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getSupportedCSSProperties(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSPropertyInfo>> out_cssProperties;
    m_agent->getSupportedCSSProperties(error, out_cssProperties);

    if (!error.length())
        result->setArray(ASCIILiteral("cssProperties"), out_cssProperties);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void CSSBackendDispatcher::getSupportedSystemFontFamilyNames(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getSupportedSystemFontFamilyNames(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<String>> out_fontFamilyNames;
    m_agent->getSupportedSystemFontFamilyNames(error, out_fontFamilyNames);

    if (!error.length())
        result->setArray(ASCIILiteral("fontFamilyNames"), out_fontFamilyNames);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void CSSBackendDispatcher::forcePseudoState(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    RefPtr<Inspector::InspectorArray> in_forcedPseudoClasses = BackendDispatcher::getArray(paramsContainer.get(), ASCIILiteral("forcedPseudoClasses"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.forcePseudoState");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->forcePseudoState(callId, in_nodeId, *in_forcedPseudoClasses);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->forcePseudoState(error, in_nodeId, *in_forcedPseudoClasses);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void CSSBackendDispatcher::getNamedFlowCollection(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_documentNodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("documentNodeId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "CSS.getNamedFlowCollection");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getNamedFlowCollection(callId, in_documentNodeId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::NamedFlow>> out_namedFlows;
    m_agent->getNamedFlowCollection(error, in_documentNodeId, out_namedFlows);

    if (!error.length())
        result->setArray(ASCIILiteral("namedFlows"), out_namedFlows);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

Ref<ConsoleBackendDispatcher> ConsoleBackendDispatcher::create(BackendDispatcher* backendDispatcher, ConsoleBackendDispatcherHandler* agent)
{
    return adoptRef(*new ConsoleBackendDispatcher(*backendDispatcher, agent));
}

ConsoleBackendDispatcher::ConsoleBackendDispatcher(BackendDispatcher& backendDispatcher, ConsoleBackendDispatcherHandler* agent)
    : SupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    , m_alternateDispatcher(nullptr)
#endif
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Console"), this);
}

void ConsoleBackendDispatcher::dispatch(long callId, const String& method, Ref<InspectorObject>&& message)
{
    Ref<ConsoleBackendDispatcher> protect(*this);

    if (method == "enable")
        enable(callId, message);
    else if (method == "disable")
        disable(callId, message);
    else if (method == "clearMessages")
        clearMessages(callId, message);
    else if (method == "setMonitoringXHREnabled")
        setMonitoringXHREnabled(callId, message);
    else if (method == "addInspectedNode")
        addInspectedNode(callId, message);
    else
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::MethodNotFound, makeString('\'', "Console", '.', method, "' was not found"));
}

void ConsoleBackendDispatcher::enable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->enable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->enable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void ConsoleBackendDispatcher::disable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->disable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->disable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void ConsoleBackendDispatcher::clearMessages(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->clearMessages(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->clearMessages(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void ConsoleBackendDispatcher::setMonitoringXHREnabled(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    bool in_enabled = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("enabled"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Console.setMonitoringXHREnabled");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setMonitoringXHREnabled(callId, in_enabled);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setMonitoringXHREnabled(error, in_enabled);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void ConsoleBackendDispatcher::addInspectedNode(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Console.addInspectedNode");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->addInspectedNode(callId, in_nodeId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->addInspectedNode(error, in_nodeId);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

Ref<DOMBackendDispatcher> DOMBackendDispatcher::create(BackendDispatcher* backendDispatcher, DOMBackendDispatcherHandler* agent)
{
    return adoptRef(*new DOMBackendDispatcher(*backendDispatcher, agent));
}

DOMBackendDispatcher::DOMBackendDispatcher(BackendDispatcher& backendDispatcher, DOMBackendDispatcherHandler* agent)
    : SupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    , m_alternateDispatcher(nullptr)
#endif
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("DOM"), this);
}

void DOMBackendDispatcher::dispatch(long callId, const String& method, Ref<InspectorObject>&& message)
{
    Ref<DOMBackendDispatcher> protect(*this);

    typedef void (DOMBackendDispatcher::*CallHandler)(long callId, const InspectorObject& message);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEPRECATED_DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, ());
    if (dispatchMap.isEmpty()) {
        static const struct MethodTable {
            const char* name;
            CallHandler handler;
        } commands[] = {
            { "getDocument", &DOMBackendDispatcher::getDocument },
            { "requestChildNodes", &DOMBackendDispatcher::requestChildNodes },
            { "querySelector", &DOMBackendDispatcher::querySelector },
            { "querySelectorAll", &DOMBackendDispatcher::querySelectorAll },
            { "setNodeName", &DOMBackendDispatcher::setNodeName },
            { "setNodeValue", &DOMBackendDispatcher::setNodeValue },
            { "removeNode", &DOMBackendDispatcher::removeNode },
            { "setAttributeValue", &DOMBackendDispatcher::setAttributeValue },
            { "setAttributesAsText", &DOMBackendDispatcher::setAttributesAsText },
            { "removeAttribute", &DOMBackendDispatcher::removeAttribute },
            { "getEventListenersForNode", &DOMBackendDispatcher::getEventListenersForNode },
            { "getAccessibilityPropertiesForNode", &DOMBackendDispatcher::getAccessibilityPropertiesForNode },
            { "getOuterHTML", &DOMBackendDispatcher::getOuterHTML },
            { "setOuterHTML", &DOMBackendDispatcher::setOuterHTML },
            { "performSearch", &DOMBackendDispatcher::performSearch },
            { "getSearchResults", &DOMBackendDispatcher::getSearchResults },
            { "discardSearchResults", &DOMBackendDispatcher::discardSearchResults },
            { "requestNode", &DOMBackendDispatcher::requestNode },
            { "setInspectModeEnabled", &DOMBackendDispatcher::setInspectModeEnabled },
            { "highlightRect", &DOMBackendDispatcher::highlightRect },
            { "highlightQuad", &DOMBackendDispatcher::highlightQuad },
            { "highlightSelector", &DOMBackendDispatcher::highlightSelector },
            { "highlightNode", &DOMBackendDispatcher::highlightNode },
            { "hideHighlight", &DOMBackendDispatcher::hideHighlight },
            { "highlightFrame", &DOMBackendDispatcher::highlightFrame },
            { "pushNodeByPathToFrontend", &DOMBackendDispatcher::pushNodeByPathToFrontend },
            { "pushNodeByBackendIdToFrontend", &DOMBackendDispatcher::pushNodeByBackendIdToFrontend },
            { "releaseBackendNodeIds", &DOMBackendDispatcher::releaseBackendNodeIds },
            { "resolveNode", &DOMBackendDispatcher::resolveNode },
            { "getAttributes", &DOMBackendDispatcher::getAttributes },
            { "moveTo", &DOMBackendDispatcher::moveTo },
            { "undo", &DOMBackendDispatcher::undo },
            { "redo", &DOMBackendDispatcher::redo },
            { "markUndoableState", &DOMBackendDispatcher::markUndoableState },
            { "focus", &DOMBackendDispatcher::focus },
        };
        size_t length = WTF_ARRAY_LENGTH(commands);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commands[i].name, commands[i].handler);
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::MethodNotFound, makeString('\'', "DOM", '.', method, "' was not found"));
        return;
    }

    ((*this).*it->value)(callId, message.get());
}

void DOMBackendDispatcher::getDocument(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getDocument(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::DOM::Node> out_root;
    m_agent->getDocument(error, out_root);

    if (!error.length())
        result->setObject(ASCIILiteral("root"), out_root);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::requestChildNodes(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    bool opt_in_depth_valueFound = false;
    int opt_in_depth = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("depth"), &opt_in_depth_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.requestChildNodes");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->requestChildNodes(callId, in_nodeId, opt_in_depth_valueFound ? &opt_in_depth : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->requestChildNodes(error, in_nodeId, opt_in_depth_valueFound ? &opt_in_depth : nullptr);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::querySelector(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    String in_selector = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("selector"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.querySelector");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->querySelector(callId, in_nodeId, in_selector);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    Inspector::Protocol::DOM::NodeId out_nodeId;
    m_agent->querySelector(error, in_nodeId, in_selector, &out_nodeId);

    if (!error.length())
        result->setInteger(ASCIILiteral("nodeId"), out_nodeId);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::querySelectorAll(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    String in_selector = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("selector"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.querySelectorAll");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->querySelectorAll(callId, in_nodeId, in_selector);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::DOM::NodeId>> out_nodeIds;
    m_agent->querySelectorAll(error, in_nodeId, in_selector, out_nodeIds);

    if (!error.length())
        result->setArray(ASCIILiteral("nodeIds"), out_nodeIds);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::setNodeName(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    String in_name = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("name"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.setNodeName");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setNodeName(callId, in_nodeId, in_name);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    Inspector::Protocol::DOM::NodeId out_nodeId;
    m_agent->setNodeName(error, in_nodeId, in_name, &out_nodeId);

    if (!error.length())
        result->setInteger(ASCIILiteral("nodeId"), out_nodeId);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::setNodeValue(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    String in_value = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("value"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.setNodeValue");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setNodeValue(callId, in_nodeId, in_value);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setNodeValue(error, in_nodeId, in_value);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::removeNode(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.removeNode");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->removeNode(callId, in_nodeId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->removeNode(error, in_nodeId);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::setAttributeValue(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    String in_name = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("name"), nullptr, protocolErrors.get());
    String in_value = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("value"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.setAttributeValue");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setAttributeValue(callId, in_nodeId, in_name, in_value);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setAttributeValue(error, in_nodeId, in_name, in_value);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::setAttributesAsText(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    String in_text = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("text"), nullptr, protocolErrors.get());
    bool opt_in_name_valueFound = false;
    String opt_in_name = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("name"), &opt_in_name_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.setAttributesAsText");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setAttributesAsText(callId, in_nodeId, in_text, opt_in_name_valueFound ? &opt_in_name : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setAttributesAsText(error, in_nodeId, in_text, opt_in_name_valueFound ? &opt_in_name : nullptr);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::removeAttribute(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    String in_name = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("name"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.removeAttribute");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->removeAttribute(callId, in_nodeId, in_name);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->removeAttribute(error, in_nodeId, in_name);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::getEventListenersForNode(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    bool opt_in_objectGroup_valueFound = false;
    String opt_in_objectGroup = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("objectGroup"), &opt_in_objectGroup_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.getEventListenersForNode");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getEventListenersForNode(callId, in_nodeId, opt_in_objectGroup_valueFound ? &opt_in_objectGroup : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::DOM::EventListener>> out_listeners;
    m_agent->getEventListenersForNode(error, in_nodeId, opt_in_objectGroup_valueFound ? &opt_in_objectGroup : nullptr, out_listeners);

    if (!error.length())
        result->setArray(ASCIILiteral("listeners"), out_listeners);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::getAccessibilityPropertiesForNode(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.getAccessibilityPropertiesForNode");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getAccessibilityPropertiesForNode(callId, in_nodeId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::DOM::AccessibilityProperties> out_properties;
    m_agent->getAccessibilityPropertiesForNode(error, in_nodeId, out_properties);

    if (!error.length())
        result->setObject(ASCIILiteral("properties"), out_properties);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::getOuterHTML(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.getOuterHTML");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getOuterHTML(callId, in_nodeId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    String out_outerHTML;
    m_agent->getOuterHTML(error, in_nodeId, &out_outerHTML);

    if (!error.length())
        result->setString(ASCIILiteral("outerHTML"), out_outerHTML);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::setOuterHTML(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    String in_outerHTML = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("outerHTML"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.setOuterHTML");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setOuterHTML(callId, in_nodeId, in_outerHTML);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setOuterHTML(error, in_nodeId, in_outerHTML);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::performSearch(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_query = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("query"), nullptr, protocolErrors.get());
    bool opt_in_nodeIds_valueFound = false;
    RefPtr<Inspector::InspectorArray> opt_in_nodeIds = BackendDispatcher::getArray(paramsContainer.get(), ASCIILiteral("nodeIds"), &opt_in_nodeIds_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.performSearch");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->performSearch(callId, in_query, opt_in_nodeIds_valueFound ? opt_in_nodeIds.get() : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    String out_searchId;
    int out_resultCount;
    m_agent->performSearch(error, in_query, opt_in_nodeIds_valueFound ? opt_in_nodeIds.get() : nullptr, &out_searchId, &out_resultCount);

    if (!error.length()) {
        result->setString(ASCIILiteral("searchId"), out_searchId);
        result->setInteger(ASCIILiteral("resultCount"), out_resultCount);
    }
    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::getSearchResults(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_searchId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("searchId"), nullptr, protocolErrors.get());
    int in_fromIndex = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("fromIndex"), nullptr, protocolErrors.get());
    int in_toIndex = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("toIndex"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.getSearchResults");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getSearchResults(callId, in_searchId, in_fromIndex, in_toIndex);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::DOM::NodeId>> out_nodeIds;
    m_agent->getSearchResults(error, in_searchId, in_fromIndex, in_toIndex, out_nodeIds);

    if (!error.length())
        result->setArray(ASCIILiteral("nodeIds"), out_nodeIds);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::discardSearchResults(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_searchId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("searchId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.discardSearchResults");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->discardSearchResults(callId, in_searchId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->discardSearchResults(error, in_searchId);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::requestNode(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_objectId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("objectId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.requestNode");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->requestNode(callId, in_objectId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    Inspector::Protocol::DOM::NodeId out_nodeId;
    m_agent->requestNode(error, in_objectId, &out_nodeId);

    if (!error.length())
        result->setInteger(ASCIILiteral("nodeId"), out_nodeId);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::setInspectModeEnabled(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    bool in_enabled = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("enabled"), nullptr, protocolErrors.get());
    bool opt_in_highlightConfig_valueFound = false;
    RefPtr<Inspector::InspectorObject> opt_in_highlightConfig = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("highlightConfig"), &opt_in_highlightConfig_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.setInspectModeEnabled");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setInspectModeEnabled(callId, in_enabled, opt_in_highlightConfig_valueFound ? opt_in_highlightConfig.get() : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setInspectModeEnabled(error, in_enabled, opt_in_highlightConfig_valueFound ? opt_in_highlightConfig.get() : nullptr);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::highlightRect(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_x = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("x"), nullptr, protocolErrors.get());
    int in_y = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("y"), nullptr, protocolErrors.get());
    int in_width = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("width"), nullptr, protocolErrors.get());
    int in_height = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("height"), nullptr, protocolErrors.get());
    bool opt_in_color_valueFound = false;
    RefPtr<Inspector::InspectorObject> opt_in_color = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("color"), &opt_in_color_valueFound, protocolErrors.get());
    bool opt_in_outlineColor_valueFound = false;
    RefPtr<Inspector::InspectorObject> opt_in_outlineColor = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("outlineColor"), &opt_in_outlineColor_valueFound, protocolErrors.get());
    bool opt_in_usePageCoordinates_valueFound = false;
    bool opt_in_usePageCoordinates = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("usePageCoordinates"), &opt_in_usePageCoordinates_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.highlightRect");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->highlightRect(callId, in_x, in_y, in_width, in_height, opt_in_color_valueFound ? opt_in_color.get() : nullptr, opt_in_outlineColor_valueFound ? opt_in_outlineColor.get() : nullptr, opt_in_usePageCoordinates_valueFound ? &opt_in_usePageCoordinates : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->highlightRect(error, in_x, in_y, in_width, in_height, opt_in_color_valueFound ? opt_in_color.get() : nullptr, opt_in_outlineColor_valueFound ? opt_in_outlineColor.get() : nullptr, opt_in_usePageCoordinates_valueFound ? &opt_in_usePageCoordinates : nullptr);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::highlightQuad(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    RefPtr<Inspector::InspectorArray> in_quad = BackendDispatcher::getArray(paramsContainer.get(), ASCIILiteral("quad"), nullptr, protocolErrors.get());
    bool opt_in_color_valueFound = false;
    RefPtr<Inspector::InspectorObject> opt_in_color = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("color"), &opt_in_color_valueFound, protocolErrors.get());
    bool opt_in_outlineColor_valueFound = false;
    RefPtr<Inspector::InspectorObject> opt_in_outlineColor = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("outlineColor"), &opt_in_outlineColor_valueFound, protocolErrors.get());
    bool opt_in_usePageCoordinates_valueFound = false;
    bool opt_in_usePageCoordinates = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("usePageCoordinates"), &opt_in_usePageCoordinates_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.highlightQuad");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->highlightQuad(callId, *in_quad, opt_in_color_valueFound ? opt_in_color.get() : nullptr, opt_in_outlineColor_valueFound ? opt_in_outlineColor.get() : nullptr, opt_in_usePageCoordinates_valueFound ? &opt_in_usePageCoordinates : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->highlightQuad(error, *in_quad, opt_in_color_valueFound ? opt_in_color.get() : nullptr, opt_in_outlineColor_valueFound ? opt_in_outlineColor.get() : nullptr, opt_in_usePageCoordinates_valueFound ? &opt_in_usePageCoordinates : nullptr);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::highlightSelector(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    RefPtr<Inspector::InspectorObject> in_highlightConfig = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("highlightConfig"), nullptr, protocolErrors.get());
    String in_selectorString = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("selectorString"), nullptr, protocolErrors.get());
    bool opt_in_frameId_valueFound = false;
    String opt_in_frameId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("frameId"), &opt_in_frameId_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.highlightSelector");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->highlightSelector(callId, *in_highlightConfig, in_selectorString, opt_in_frameId_valueFound ? &opt_in_frameId : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->highlightSelector(error, *in_highlightConfig, in_selectorString, opt_in_frameId_valueFound ? &opt_in_frameId : nullptr);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::highlightNode(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    RefPtr<Inspector::InspectorObject> in_highlightConfig = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("highlightConfig"), nullptr, protocolErrors.get());
    bool opt_in_nodeId_valueFound = false;
    int opt_in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), &opt_in_nodeId_valueFound, protocolErrors.get());
    bool opt_in_objectId_valueFound = false;
    String opt_in_objectId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("objectId"), &opt_in_objectId_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.highlightNode");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->highlightNode(callId, *in_highlightConfig, opt_in_nodeId_valueFound ? &opt_in_nodeId : nullptr, opt_in_objectId_valueFound ? &opt_in_objectId : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->highlightNode(error, *in_highlightConfig, opt_in_nodeId_valueFound ? &opt_in_nodeId : nullptr, opt_in_objectId_valueFound ? &opt_in_objectId : nullptr);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::hideHighlight(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->hideHighlight(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->hideHighlight(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::highlightFrame(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_frameId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("frameId"), nullptr, protocolErrors.get());
    bool opt_in_contentColor_valueFound = false;
    RefPtr<Inspector::InspectorObject> opt_in_contentColor = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("contentColor"), &opt_in_contentColor_valueFound, protocolErrors.get());
    bool opt_in_contentOutlineColor_valueFound = false;
    RefPtr<Inspector::InspectorObject> opt_in_contentOutlineColor = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("contentOutlineColor"), &opt_in_contentOutlineColor_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.highlightFrame");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->highlightFrame(callId, in_frameId, opt_in_contentColor_valueFound ? opt_in_contentColor.get() : nullptr, opt_in_contentOutlineColor_valueFound ? opt_in_contentOutlineColor.get() : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->highlightFrame(error, in_frameId, opt_in_contentColor_valueFound ? opt_in_contentColor.get() : nullptr, opt_in_contentOutlineColor_valueFound ? opt_in_contentOutlineColor.get() : nullptr);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::pushNodeByPathToFrontend(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_path = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("path"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.pushNodeByPathToFrontend");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->pushNodeByPathToFrontend(callId, in_path);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    Inspector::Protocol::DOM::NodeId out_nodeId;
    m_agent->pushNodeByPathToFrontend(error, in_path, &out_nodeId);

    if (!error.length())
        result->setInteger(ASCIILiteral("nodeId"), out_nodeId);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::pushNodeByBackendIdToFrontend(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_backendNodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("backendNodeId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.pushNodeByBackendIdToFrontend");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->pushNodeByBackendIdToFrontend(callId, in_backendNodeId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    Inspector::Protocol::DOM::NodeId out_nodeId;
    m_agent->pushNodeByBackendIdToFrontend(error, in_backendNodeId, &out_nodeId);

    if (!error.length())
        result->setInteger(ASCIILiteral("nodeId"), out_nodeId);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::releaseBackendNodeIds(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_nodeGroup = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("nodeGroup"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.releaseBackendNodeIds");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->releaseBackendNodeIds(callId, in_nodeGroup);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->releaseBackendNodeIds(error, in_nodeGroup);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::resolveNode(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    bool opt_in_objectGroup_valueFound = false;
    String opt_in_objectGroup = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("objectGroup"), &opt_in_objectGroup_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.resolveNode");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->resolveNode(callId, in_nodeId, opt_in_objectGroup_valueFound ? &opt_in_objectGroup : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Runtime::RemoteObject> out_object;
    m_agent->resolveNode(error, in_nodeId, opt_in_objectGroup_valueFound ? &opt_in_objectGroup : nullptr, out_object);

    if (!error.length())
        result->setObject(ASCIILiteral("object"), out_object);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::getAttributes(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.getAttributes");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getAttributes(callId, in_nodeId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<String>> out_attributes;
    m_agent->getAttributes(error, in_nodeId, out_attributes);

    if (!error.length())
        result->setArray(ASCIILiteral("attributes"), out_attributes);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::moveTo(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    int in_targetNodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("targetNodeId"), nullptr, protocolErrors.get());
    bool opt_in_insertBeforeNodeId_valueFound = false;
    int opt_in_insertBeforeNodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("insertBeforeNodeId"), &opt_in_insertBeforeNodeId_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.moveTo");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->moveTo(callId, in_nodeId, in_targetNodeId, opt_in_insertBeforeNodeId_valueFound ? &opt_in_insertBeforeNodeId : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    Inspector::Protocol::DOM::NodeId out_nodeId;
    m_agent->moveTo(error, in_nodeId, in_targetNodeId, opt_in_insertBeforeNodeId_valueFound ? &opt_in_insertBeforeNodeId : nullptr, &out_nodeId);

    if (!error.length())
        result->setInteger(ASCIILiteral("nodeId"), out_nodeId);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::undo(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->undo(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->undo(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::redo(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->redo(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->redo(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::markUndoableState(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->markUndoableState(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->markUndoableState(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMBackendDispatcher::focus(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOM.focus");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->focus(callId, in_nodeId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->focus(error, in_nodeId);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

Ref<DOMDebuggerBackendDispatcher> DOMDebuggerBackendDispatcher::create(BackendDispatcher* backendDispatcher, DOMDebuggerBackendDispatcherHandler* agent)
{
    return adoptRef(*new DOMDebuggerBackendDispatcher(*backendDispatcher, agent));
}

DOMDebuggerBackendDispatcher::DOMDebuggerBackendDispatcher(BackendDispatcher& backendDispatcher, DOMDebuggerBackendDispatcherHandler* agent)
    : SupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    , m_alternateDispatcher(nullptr)
#endif
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("DOMDebugger"), this);
}

void DOMDebuggerBackendDispatcher::dispatch(long callId, const String& method, Ref<InspectorObject>&& message)
{
    Ref<DOMDebuggerBackendDispatcher> protect(*this);

    typedef void (DOMDebuggerBackendDispatcher::*CallHandler)(long callId, const InspectorObject& message);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEPRECATED_DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, ());
    if (dispatchMap.isEmpty()) {
        static const struct MethodTable {
            const char* name;
            CallHandler handler;
        } commands[] = {
            { "setDOMBreakpoint", &DOMDebuggerBackendDispatcher::setDOMBreakpoint },
            { "removeDOMBreakpoint", &DOMDebuggerBackendDispatcher::removeDOMBreakpoint },
            { "setEventListenerBreakpoint", &DOMDebuggerBackendDispatcher::setEventListenerBreakpoint },
            { "removeEventListenerBreakpoint", &DOMDebuggerBackendDispatcher::removeEventListenerBreakpoint },
            { "setInstrumentationBreakpoint", &DOMDebuggerBackendDispatcher::setInstrumentationBreakpoint },
            { "removeInstrumentationBreakpoint", &DOMDebuggerBackendDispatcher::removeInstrumentationBreakpoint },
            { "setXHRBreakpoint", &DOMDebuggerBackendDispatcher::setXHRBreakpoint },
            { "removeXHRBreakpoint", &DOMDebuggerBackendDispatcher::removeXHRBreakpoint },
        };
        size_t length = WTF_ARRAY_LENGTH(commands);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commands[i].name, commands[i].handler);
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::MethodNotFound, makeString('\'', "DOMDebugger", '.', method, "' was not found"));
        return;
    }

    ((*this).*it->value)(callId, message.get());
}

void DOMDebuggerBackendDispatcher::setDOMBreakpoint(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    String in_type = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("type"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.setDOMBreakpoint");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setDOMBreakpoint(callId, in_nodeId, in_type);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setDOMBreakpoint(error, in_nodeId, in_type);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMDebuggerBackendDispatcher::removeDOMBreakpoint(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    String in_type = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("type"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.removeDOMBreakpoint");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->removeDOMBreakpoint(callId, in_nodeId, in_type);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->removeDOMBreakpoint(error, in_nodeId, in_type);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMDebuggerBackendDispatcher::setEventListenerBreakpoint(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_eventName = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("eventName"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.setEventListenerBreakpoint");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setEventListenerBreakpoint(callId, in_eventName);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setEventListenerBreakpoint(error, in_eventName);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMDebuggerBackendDispatcher::removeEventListenerBreakpoint(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_eventName = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("eventName"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.removeEventListenerBreakpoint");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->removeEventListenerBreakpoint(callId, in_eventName);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->removeEventListenerBreakpoint(error, in_eventName);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMDebuggerBackendDispatcher::setInstrumentationBreakpoint(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_eventName = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("eventName"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.setInstrumentationBreakpoint");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setInstrumentationBreakpoint(callId, in_eventName);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setInstrumentationBreakpoint(error, in_eventName);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMDebuggerBackendDispatcher::removeInstrumentationBreakpoint(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_eventName = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("eventName"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.removeInstrumentationBreakpoint");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->removeInstrumentationBreakpoint(callId, in_eventName);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->removeInstrumentationBreakpoint(error, in_eventName);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMDebuggerBackendDispatcher::setXHRBreakpoint(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_url = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("url"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.setXHRBreakpoint");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setXHRBreakpoint(callId, in_url);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setXHRBreakpoint(error, in_url);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMDebuggerBackendDispatcher::removeXHRBreakpoint(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_url = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("url"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.removeXHRBreakpoint");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->removeXHRBreakpoint(callId, in_url);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->removeXHRBreakpoint(error, in_url);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

Ref<DOMStorageBackendDispatcher> DOMStorageBackendDispatcher::create(BackendDispatcher* backendDispatcher, DOMStorageBackendDispatcherHandler* agent)
{
    return adoptRef(*new DOMStorageBackendDispatcher(*backendDispatcher, agent));
}

DOMStorageBackendDispatcher::DOMStorageBackendDispatcher(BackendDispatcher& backendDispatcher, DOMStorageBackendDispatcherHandler* agent)
    : SupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    , m_alternateDispatcher(nullptr)
#endif
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("DOMStorage"), this);
}

void DOMStorageBackendDispatcher::dispatch(long callId, const String& method, Ref<InspectorObject>&& message)
{
    Ref<DOMStorageBackendDispatcher> protect(*this);

    if (method == "enable")
        enable(callId, message);
    else if (method == "disable")
        disable(callId, message);
    else if (method == "getDOMStorageItems")
        getDOMStorageItems(callId, message);
    else if (method == "setDOMStorageItem")
        setDOMStorageItem(callId, message);
    else if (method == "removeDOMStorageItem")
        removeDOMStorageItem(callId, message);
    else
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::MethodNotFound, makeString('\'', "DOMStorage", '.', method, "' was not found"));
}

void DOMStorageBackendDispatcher::enable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->enable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->enable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMStorageBackendDispatcher::disable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->disable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->disable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMStorageBackendDispatcher::getDOMStorageItems(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    RefPtr<Inspector::InspectorObject> in_storageId = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("storageId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMStorage.getDOMStorageItems");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getDOMStorageItems(callId, *in_storageId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::DOMStorage::Item>> out_entries;
    m_agent->getDOMStorageItems(error, *in_storageId, out_entries);

    if (!error.length())
        result->setArray(ASCIILiteral("entries"), out_entries);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMStorageBackendDispatcher::setDOMStorageItem(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    RefPtr<Inspector::InspectorObject> in_storageId = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("storageId"), nullptr, protocolErrors.get());
    String in_key = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("key"), nullptr, protocolErrors.get());
    String in_value = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("value"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMStorage.setDOMStorageItem");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setDOMStorageItem(callId, *in_storageId, in_key, in_value);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setDOMStorageItem(error, *in_storageId, in_key, in_value);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DOMStorageBackendDispatcher::removeDOMStorageItem(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    RefPtr<Inspector::InspectorObject> in_storageId = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("storageId"), nullptr, protocolErrors.get());
    String in_key = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("key"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "DOMStorage.removeDOMStorageItem");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->removeDOMStorageItem(callId, *in_storageId, in_key);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->removeDOMStorageItem(error, *in_storageId, in_key);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

Ref<DatabaseBackendDispatcher> DatabaseBackendDispatcher::create(BackendDispatcher* backendDispatcher, DatabaseBackendDispatcherHandler* agent)
{
    return adoptRef(*new DatabaseBackendDispatcher(*backendDispatcher, agent));
}

DatabaseBackendDispatcher::DatabaseBackendDispatcher(BackendDispatcher& backendDispatcher, DatabaseBackendDispatcherHandler* agent)
    : SupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    , m_alternateDispatcher(nullptr)
#endif
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Database"), this);
}

void DatabaseBackendDispatcher::dispatch(long callId, const String& method, Ref<InspectorObject>&& message)
{
    Ref<DatabaseBackendDispatcher> protect(*this);

    if (method == "enable")
        enable(callId, message);
    else if (method == "disable")
        disable(callId, message);
    else if (method == "getDatabaseTableNames")
        getDatabaseTableNames(callId, message);
    else if (method == "executeSQL")
        executeSQL(callId, message);
    else
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::MethodNotFound, makeString('\'', "Database", '.', method, "' was not found"));
}

void DatabaseBackendDispatcher::enable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->enable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->enable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DatabaseBackendDispatcher::disable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->disable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->disable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DatabaseBackendDispatcher::getDatabaseTableNames(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_databaseId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("databaseId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Database.getDatabaseTableNames");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getDatabaseTableNames(callId, in_databaseId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<String>> out_tableNames;
    m_agent->getDatabaseTableNames(error, in_databaseId, out_tableNames);

    if (!error.length())
        result->setArray(ASCIILiteral("tableNames"), out_tableNames);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

DatabaseBackendDispatcherHandler::ExecuteSQLCallback::ExecuteSQLCallback(Ref<BackendDispatcher>&& backendDispatcher, int id) : BackendDispatcher::CallbackBase(WTF::move(backendDispatcher), id) { }

void DatabaseBackendDispatcherHandler::ExecuteSQLCallback::sendSuccess(RefPtr<Inspector::Protocol::Array<String>>&& columnNames, RefPtr<Inspector::Protocol::Array<Inspector::InspectorValue>>&& values, RefPtr<Inspector::Protocol::Database::Error>&& sqlError)
{
    Ref<InspectorObject> jsonMessage = InspectorObject::create();
    if (columnNames)
        jsonMessage->setArray(ASCIILiteral("columnNames"), columnNames);
    if (values)
        jsonMessage->setArray(ASCIILiteral("values"), values);
    if (sqlError)
        jsonMessage->setObject(ASCIILiteral("sqlError"), sqlError);
    sendIfActive(WTF::move(jsonMessage), ErrorString());
}

void DatabaseBackendDispatcher::executeSQL(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_databaseId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("databaseId"), nullptr, protocolErrors.get());
    String in_query = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("query"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Database.executeSQL");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->executeSQL(callId, in_databaseId, in_query);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    Ref<DatabaseBackendDispatcherHandler::ExecuteSQLCallback> callback = adoptRef(*new DatabaseBackendDispatcherHandler::ExecuteSQLCallback(m_backendDispatcher.copyRef(), callId));
    m_agent->executeSQL(error, in_databaseId, in_query, callback.copyRef());

    if (error.length()) {
        callback->disable();
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::ServerError, error);
        return;
    }
}

Ref<DebuggerBackendDispatcher> DebuggerBackendDispatcher::create(BackendDispatcher* backendDispatcher, DebuggerBackendDispatcherHandler* agent)
{
    return adoptRef(*new DebuggerBackendDispatcher(*backendDispatcher, agent));
}

DebuggerBackendDispatcher::DebuggerBackendDispatcher(BackendDispatcher& backendDispatcher, DebuggerBackendDispatcherHandler* agent)
    : SupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    , m_alternateDispatcher(nullptr)
#endif
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Debugger"), this);
}

void DebuggerBackendDispatcher::dispatch(long callId, const String& method, Ref<InspectorObject>&& message)
{
    Ref<DebuggerBackendDispatcher> protect(*this);

    typedef void (DebuggerBackendDispatcher::*CallHandler)(long callId, const InspectorObject& message);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEPRECATED_DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, ());
    if (dispatchMap.isEmpty()) {
        static const struct MethodTable {
            const char* name;
            CallHandler handler;
        } commands[] = {
            { "enable", &DebuggerBackendDispatcher::enable },
            { "disable", &DebuggerBackendDispatcher::disable },
            { "setBreakpointsActive", &DebuggerBackendDispatcher::setBreakpointsActive },
            { "setBreakpointByUrl", &DebuggerBackendDispatcher::setBreakpointByUrl },
            { "setBreakpoint", &DebuggerBackendDispatcher::setBreakpoint },
            { "removeBreakpoint", &DebuggerBackendDispatcher::removeBreakpoint },
            { "continueToLocation", &DebuggerBackendDispatcher::continueToLocation },
            { "stepOver", &DebuggerBackendDispatcher::stepOver },
            { "stepInto", &DebuggerBackendDispatcher::stepInto },
            { "stepOut", &DebuggerBackendDispatcher::stepOut },
            { "pause", &DebuggerBackendDispatcher::pause },
            { "resume", &DebuggerBackendDispatcher::resume },
            { "searchInContent", &DebuggerBackendDispatcher::searchInContent },
            { "getScriptSource", &DebuggerBackendDispatcher::getScriptSource },
            { "getFunctionDetails", &DebuggerBackendDispatcher::getFunctionDetails },
            { "setPauseOnExceptions", &DebuggerBackendDispatcher::setPauseOnExceptions },
            { "evaluateOnCallFrame", &DebuggerBackendDispatcher::evaluateOnCallFrame },
            { "setOverlayMessage", &DebuggerBackendDispatcher::setOverlayMessage },
        };
        size_t length = WTF_ARRAY_LENGTH(commands);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commands[i].name, commands[i].handler);
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::MethodNotFound, makeString('\'', "Debugger", '.', method, "' was not found"));
        return;
    }

    ((*this).*it->value)(callId, message.get());
}

void DebuggerBackendDispatcher::enable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->enable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->enable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DebuggerBackendDispatcher::disable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->disable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->disable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DebuggerBackendDispatcher::setBreakpointsActive(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    bool in_active = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("active"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Debugger.setBreakpointsActive");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setBreakpointsActive(callId, in_active);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setBreakpointsActive(error, in_active);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DebuggerBackendDispatcher::setBreakpointByUrl(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_lineNumber = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("lineNumber"), nullptr, protocolErrors.get());
    bool opt_in_url_valueFound = false;
    String opt_in_url = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("url"), &opt_in_url_valueFound, protocolErrors.get());
    bool opt_in_urlRegex_valueFound = false;
    String opt_in_urlRegex = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("urlRegex"), &opt_in_urlRegex_valueFound, protocolErrors.get());
    bool opt_in_columnNumber_valueFound = false;
    int opt_in_columnNumber = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("columnNumber"), &opt_in_columnNumber_valueFound, protocolErrors.get());
    bool opt_in_options_valueFound = false;
    RefPtr<Inspector::InspectorObject> opt_in_options = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("options"), &opt_in_options_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Debugger.setBreakpointByUrl");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setBreakpointByUrl(callId, in_lineNumber, opt_in_url_valueFound ? &opt_in_url : nullptr, opt_in_urlRegex_valueFound ? &opt_in_urlRegex : nullptr, opt_in_columnNumber_valueFound ? &opt_in_columnNumber : nullptr, opt_in_options_valueFound ? opt_in_options.get() : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    Inspector::Protocol::Debugger::BreakpointId out_breakpointId;
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Debugger::Location>> out_locations;
    m_agent->setBreakpointByUrl(error, in_lineNumber, opt_in_url_valueFound ? &opt_in_url : nullptr, opt_in_urlRegex_valueFound ? &opt_in_urlRegex : nullptr, opt_in_columnNumber_valueFound ? &opt_in_columnNumber : nullptr, opt_in_options_valueFound ? opt_in_options.get() : nullptr, &out_breakpointId, out_locations);

    if (!error.length()) {
        result->setString(ASCIILiteral("breakpointId"), out_breakpointId);
        result->setArray(ASCIILiteral("locations"), out_locations);
    }
    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DebuggerBackendDispatcher::setBreakpoint(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    RefPtr<Inspector::InspectorObject> in_location = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("location"), nullptr, protocolErrors.get());
    bool opt_in_options_valueFound = false;
    RefPtr<Inspector::InspectorObject> opt_in_options = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("options"), &opt_in_options_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Debugger.setBreakpoint");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setBreakpoint(callId, *in_location, opt_in_options_valueFound ? opt_in_options.get() : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    Inspector::Protocol::Debugger::BreakpointId out_breakpointId;
    RefPtr<Inspector::Protocol::Debugger::Location> out_actualLocation;
    m_agent->setBreakpoint(error, *in_location, opt_in_options_valueFound ? opt_in_options.get() : nullptr, &out_breakpointId, out_actualLocation);

    if (!error.length()) {
        result->setString(ASCIILiteral("breakpointId"), out_breakpointId);
        result->setObject(ASCIILiteral("actualLocation"), out_actualLocation);
    }
    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DebuggerBackendDispatcher::removeBreakpoint(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_breakpointId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("breakpointId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Debugger.removeBreakpoint");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->removeBreakpoint(callId, in_breakpointId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->removeBreakpoint(error, in_breakpointId);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DebuggerBackendDispatcher::continueToLocation(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    RefPtr<Inspector::InspectorObject> in_location = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("location"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Debugger.continueToLocation");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->continueToLocation(callId, *in_location);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->continueToLocation(error, *in_location);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DebuggerBackendDispatcher::stepOver(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->stepOver(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->stepOver(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DebuggerBackendDispatcher::stepInto(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->stepInto(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->stepInto(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DebuggerBackendDispatcher::stepOut(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->stepOut(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->stepOut(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DebuggerBackendDispatcher::pause(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->pause(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->pause(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DebuggerBackendDispatcher::resume(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->resume(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->resume(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DebuggerBackendDispatcher::searchInContent(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_scriptId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("scriptId"), nullptr, protocolErrors.get());
    String in_query = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("query"), nullptr, protocolErrors.get());
    bool opt_in_caseSensitive_valueFound = false;
    bool opt_in_caseSensitive = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("caseSensitive"), &opt_in_caseSensitive_valueFound, protocolErrors.get());
    bool opt_in_isRegex_valueFound = false;
    bool opt_in_isRegex = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("isRegex"), &opt_in_isRegex_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Debugger.searchInContent");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->searchInContent(callId, in_scriptId, in_query, opt_in_caseSensitive_valueFound ? &opt_in_caseSensitive : nullptr, opt_in_isRegex_valueFound ? &opt_in_isRegex : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::GenericTypes::SearchMatch>> out_result;
    m_agent->searchInContent(error, in_scriptId, in_query, opt_in_caseSensitive_valueFound ? &opt_in_caseSensitive : nullptr, opt_in_isRegex_valueFound ? &opt_in_isRegex : nullptr, out_result);

    if (!error.length())
        result->setArray(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DebuggerBackendDispatcher::getScriptSource(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_scriptId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("scriptId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Debugger.getScriptSource");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getScriptSource(callId, in_scriptId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    String out_scriptSource;
    m_agent->getScriptSource(error, in_scriptId, &out_scriptSource);

    if (!error.length())
        result->setString(ASCIILiteral("scriptSource"), out_scriptSource);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DebuggerBackendDispatcher::getFunctionDetails(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_functionId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("functionId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Debugger.getFunctionDetails");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getFunctionDetails(callId, in_functionId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Debugger::FunctionDetails> out_details;
    m_agent->getFunctionDetails(error, in_functionId, out_details);

    if (!error.length())
        result->setObject(ASCIILiteral("details"), out_details);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DebuggerBackendDispatcher::setPauseOnExceptions(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_state = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("state"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Debugger.setPauseOnExceptions");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setPauseOnExceptions(callId, in_state);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setPauseOnExceptions(error, in_state);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DebuggerBackendDispatcher::evaluateOnCallFrame(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_callFrameId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("callFrameId"), nullptr, protocolErrors.get());
    String in_expression = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("expression"), nullptr, protocolErrors.get());
    bool opt_in_objectGroup_valueFound = false;
    String opt_in_objectGroup = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("objectGroup"), &opt_in_objectGroup_valueFound, protocolErrors.get());
    bool opt_in_includeCommandLineAPI_valueFound = false;
    bool opt_in_includeCommandLineAPI = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("includeCommandLineAPI"), &opt_in_includeCommandLineAPI_valueFound, protocolErrors.get());
    bool opt_in_doNotPauseOnExceptionsAndMuteConsole_valueFound = false;
    bool opt_in_doNotPauseOnExceptionsAndMuteConsole = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("doNotPauseOnExceptionsAndMuteConsole"), &opt_in_doNotPauseOnExceptionsAndMuteConsole_valueFound, protocolErrors.get());
    bool opt_in_returnByValue_valueFound = false;
    bool opt_in_returnByValue = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("returnByValue"), &opt_in_returnByValue_valueFound, protocolErrors.get());
    bool opt_in_generatePreview_valueFound = false;
    bool opt_in_generatePreview = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("generatePreview"), &opt_in_generatePreview_valueFound, protocolErrors.get());
    bool opt_in_saveResult_valueFound = false;
    bool opt_in_saveResult = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("saveResult"), &opt_in_saveResult_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Debugger.evaluateOnCallFrame");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->evaluateOnCallFrame(callId, in_callFrameId, in_expression, opt_in_objectGroup_valueFound ? &opt_in_objectGroup : nullptr, opt_in_includeCommandLineAPI_valueFound ? &opt_in_includeCommandLineAPI : nullptr, opt_in_doNotPauseOnExceptionsAndMuteConsole_valueFound ? &opt_in_doNotPauseOnExceptionsAndMuteConsole : nullptr, opt_in_returnByValue_valueFound ? &opt_in_returnByValue : nullptr, opt_in_generatePreview_valueFound ? &opt_in_generatePreview : nullptr, opt_in_saveResult_valueFound ? &opt_in_saveResult : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Runtime::RemoteObject> out_result;
    Inspector::Protocol::OptOutput<bool> out_wasThrown;
    Inspector::Protocol::OptOutput<int> out_savedResultIndex;
    m_agent->evaluateOnCallFrame(error, in_callFrameId, in_expression, opt_in_objectGroup_valueFound ? &opt_in_objectGroup : nullptr, opt_in_includeCommandLineAPI_valueFound ? &opt_in_includeCommandLineAPI : nullptr, opt_in_doNotPauseOnExceptionsAndMuteConsole_valueFound ? &opt_in_doNotPauseOnExceptionsAndMuteConsole : nullptr, opt_in_returnByValue_valueFound ? &opt_in_returnByValue : nullptr, opt_in_generatePreview_valueFound ? &opt_in_generatePreview : nullptr, opt_in_saveResult_valueFound ? &opt_in_saveResult : nullptr, out_result, &out_wasThrown, &out_savedResultIndex);

    if (!error.length()) {
        result->setObject(ASCIILiteral("result"), out_result);
        if (out_wasThrown.isAssigned())
            result->setBoolean(ASCIILiteral("wasThrown"), out_wasThrown.getValue());
        if (out_savedResultIndex.isAssigned())
            result->setInteger(ASCIILiteral("savedResultIndex"), out_savedResultIndex.getValue());
    }
    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void DebuggerBackendDispatcher::setOverlayMessage(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    bool opt_in_message_valueFound = false;
    String opt_in_message = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("message"), &opt_in_message_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Debugger.setOverlayMessage");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setOverlayMessage(callId, opt_in_message_valueFound ? &opt_in_message : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setOverlayMessage(error, opt_in_message_valueFound ? &opt_in_message : nullptr);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

Ref<InspectorBackendDispatcher> InspectorBackendDispatcher::create(BackendDispatcher* backendDispatcher, InspectorBackendDispatcherHandler* agent)
{
    return adoptRef(*new InspectorBackendDispatcher(*backendDispatcher, agent));
}

InspectorBackendDispatcher::InspectorBackendDispatcher(BackendDispatcher& backendDispatcher, InspectorBackendDispatcherHandler* agent)
    : SupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    , m_alternateDispatcher(nullptr)
#endif
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Inspector"), this);
}

void InspectorBackendDispatcher::dispatch(long callId, const String& method, Ref<InspectorObject>&& message)
{
    Ref<InspectorBackendDispatcher> protect(*this);

    if (method == "enable")
        enable(callId, message);
    else if (method == "disable")
        disable(callId, message);
    else if (method == "initialized")
        initialized(callId, message);
    else
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::MethodNotFound, makeString('\'', "Inspector", '.', method, "' was not found"));
}

void InspectorBackendDispatcher::enable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->enable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->enable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void InspectorBackendDispatcher::disable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->disable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->disable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void InspectorBackendDispatcher::initialized(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->initialized(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->initialized(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

Ref<LayerTreeBackendDispatcher> LayerTreeBackendDispatcher::create(BackendDispatcher* backendDispatcher, LayerTreeBackendDispatcherHandler* agent)
{
    return adoptRef(*new LayerTreeBackendDispatcher(*backendDispatcher, agent));
}

LayerTreeBackendDispatcher::LayerTreeBackendDispatcher(BackendDispatcher& backendDispatcher, LayerTreeBackendDispatcherHandler* agent)
    : SupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    , m_alternateDispatcher(nullptr)
#endif
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("LayerTree"), this);
}

void LayerTreeBackendDispatcher::dispatch(long callId, const String& method, Ref<InspectorObject>&& message)
{
    Ref<LayerTreeBackendDispatcher> protect(*this);

    if (method == "enable")
        enable(callId, message);
    else if (method == "disable")
        disable(callId, message);
    else if (method == "layersForNode")
        layersForNode(callId, message);
    else if (method == "reasonsForCompositingLayer")
        reasonsForCompositingLayer(callId, message);
    else
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::MethodNotFound, makeString('\'', "LayerTree", '.', method, "' was not found"));
}

void LayerTreeBackendDispatcher::enable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->enable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->enable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void LayerTreeBackendDispatcher::disable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->disable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->disable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void LayerTreeBackendDispatcher::layersForNode(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "LayerTree.layersForNode");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->layersForNode(callId, in_nodeId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::LayerTree::Layer>> out_layers;
    m_agent->layersForNode(error, in_nodeId, out_layers);

    if (!error.length())
        result->setArray(ASCIILiteral("layers"), out_layers);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void LayerTreeBackendDispatcher::reasonsForCompositingLayer(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_layerId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("layerId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "LayerTree.reasonsForCompositingLayer");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->reasonsForCompositingLayer(callId, in_layerId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::LayerTree::CompositingReasons> out_compositingReasons;
    m_agent->reasonsForCompositingLayer(error, in_layerId, out_compositingReasons);

    if (!error.length())
        result->setObject(ASCIILiteral("compositingReasons"), out_compositingReasons);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

Ref<NetworkBackendDispatcher> NetworkBackendDispatcher::create(BackendDispatcher* backendDispatcher, NetworkBackendDispatcherHandler* agent)
{
    return adoptRef(*new NetworkBackendDispatcher(*backendDispatcher, agent));
}

NetworkBackendDispatcher::NetworkBackendDispatcher(BackendDispatcher& backendDispatcher, NetworkBackendDispatcherHandler* agent)
    : SupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    , m_alternateDispatcher(nullptr)
#endif
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Network"), this);
}

void NetworkBackendDispatcher::dispatch(long callId, const String& method, Ref<InspectorObject>&& message)
{
    Ref<NetworkBackendDispatcher> protect(*this);

    typedef void (NetworkBackendDispatcher::*CallHandler)(long callId, const InspectorObject& message);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEPRECATED_DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, ());
    if (dispatchMap.isEmpty()) {
        static const struct MethodTable {
            const char* name;
            CallHandler handler;
        } commands[] = {
            { "enable", &NetworkBackendDispatcher::enable },
            { "disable", &NetworkBackendDispatcher::disable },
            { "setExtraHTTPHeaders", &NetworkBackendDispatcher::setExtraHTTPHeaders },
            { "getResponseBody", &NetworkBackendDispatcher::getResponseBody },
            { "canClearBrowserCache", &NetworkBackendDispatcher::canClearBrowserCache },
            { "clearBrowserCache", &NetworkBackendDispatcher::clearBrowserCache },
            { "canClearBrowserCookies", &NetworkBackendDispatcher::canClearBrowserCookies },
            { "clearBrowserCookies", &NetworkBackendDispatcher::clearBrowserCookies },
            { "setCacheDisabled", &NetworkBackendDispatcher::setCacheDisabled },
            { "loadResource", &NetworkBackendDispatcher::loadResource },
        };
        size_t length = WTF_ARRAY_LENGTH(commands);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commands[i].name, commands[i].handler);
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::MethodNotFound, makeString('\'', "Network", '.', method, "' was not found"));
        return;
    }

    ((*this).*it->value)(callId, message.get());
}

void NetworkBackendDispatcher::enable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->enable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->enable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void NetworkBackendDispatcher::disable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->disable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->disable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void NetworkBackendDispatcher::setExtraHTTPHeaders(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    RefPtr<Inspector::InspectorObject> in_headers = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("headers"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Network.setExtraHTTPHeaders");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setExtraHTTPHeaders(callId, *in_headers);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setExtraHTTPHeaders(error, *in_headers);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void NetworkBackendDispatcher::getResponseBody(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_requestId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("requestId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Network.getResponseBody");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getResponseBody(callId, in_requestId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    String out_body;
    bool out_base64Encoded;
    m_agent->getResponseBody(error, in_requestId, &out_body, &out_base64Encoded);

    if (!error.length()) {
        result->setString(ASCIILiteral("body"), out_body);
        result->setBoolean(ASCIILiteral("base64Encoded"), out_base64Encoded);
    }
    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void NetworkBackendDispatcher::canClearBrowserCache(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->canClearBrowserCache(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    bool out_result;
    m_agent->canClearBrowserCache(error, &out_result);

    if (!error.length())
        result->setBoolean(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void NetworkBackendDispatcher::clearBrowserCache(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->clearBrowserCache(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->clearBrowserCache(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void NetworkBackendDispatcher::canClearBrowserCookies(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->canClearBrowserCookies(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    bool out_result;
    m_agent->canClearBrowserCookies(error, &out_result);

    if (!error.length())
        result->setBoolean(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void NetworkBackendDispatcher::clearBrowserCookies(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->clearBrowserCookies(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->clearBrowserCookies(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void NetworkBackendDispatcher::setCacheDisabled(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    bool in_cacheDisabled = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("cacheDisabled"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Network.setCacheDisabled");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setCacheDisabled(callId, in_cacheDisabled);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setCacheDisabled(error, in_cacheDisabled);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

NetworkBackendDispatcherHandler::LoadResourceCallback::LoadResourceCallback(Ref<BackendDispatcher>&& backendDispatcher, int id) : BackendDispatcher::CallbackBase(WTF::move(backendDispatcher), id) { }

void NetworkBackendDispatcherHandler::LoadResourceCallback::sendSuccess(const String& content, const String& mimeType, double status)
{
    Ref<InspectorObject> jsonMessage = InspectorObject::create();
    jsonMessage->setString(ASCIILiteral("content"), content);
    jsonMessage->setString(ASCIILiteral("mimeType"), mimeType);
    jsonMessage->setDouble(ASCIILiteral("status"), status);
    sendIfActive(WTF::move(jsonMessage), ErrorString());
}

void NetworkBackendDispatcher::loadResource(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_frameId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("frameId"), nullptr, protocolErrors.get());
    String in_url = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("url"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Network.loadResource");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->loadResource(callId, in_frameId, in_url);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    Ref<NetworkBackendDispatcherHandler::LoadResourceCallback> callback = adoptRef(*new NetworkBackendDispatcherHandler::LoadResourceCallback(m_backendDispatcher.copyRef(), callId));
    m_agent->loadResource(error, in_frameId, in_url, callback.copyRef());

    if (error.length()) {
        callback->disable();
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::ServerError, error);
        return;
    }
}

Ref<PageBackendDispatcher> PageBackendDispatcher::create(BackendDispatcher* backendDispatcher, PageBackendDispatcherHandler* agent)
{
    return adoptRef(*new PageBackendDispatcher(*backendDispatcher, agent));
}

PageBackendDispatcher::PageBackendDispatcher(BackendDispatcher& backendDispatcher, PageBackendDispatcherHandler* agent)
    : SupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    , m_alternateDispatcher(nullptr)
#endif
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Page"), this);
}

void PageBackendDispatcher::dispatch(long callId, const String& method, Ref<InspectorObject>&& message)
{
    Ref<PageBackendDispatcher> protect(*this);

    typedef void (PageBackendDispatcher::*CallHandler)(long callId, const InspectorObject& message);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEPRECATED_DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, ());
    if (dispatchMap.isEmpty()) {
        static const struct MethodTable {
            const char* name;
            CallHandler handler;
        } commands[] = {
            { "enable", &PageBackendDispatcher::enable },
            { "disable", &PageBackendDispatcher::disable },
            { "addScriptToEvaluateOnLoad", &PageBackendDispatcher::addScriptToEvaluateOnLoad },
            { "removeScriptToEvaluateOnLoad", &PageBackendDispatcher::removeScriptToEvaluateOnLoad },
            { "reload", &PageBackendDispatcher::reload },
            { "navigate", &PageBackendDispatcher::navigate },
            { "getCookies", &PageBackendDispatcher::getCookies },
            { "deleteCookie", &PageBackendDispatcher::deleteCookie },
            { "getResourceTree", &PageBackendDispatcher::getResourceTree },
            { "getResourceContent", &PageBackendDispatcher::getResourceContent },
            { "searchInResource", &PageBackendDispatcher::searchInResource },
            { "searchInResources", &PageBackendDispatcher::searchInResources },
            { "setDocumentContent", &PageBackendDispatcher::setDocumentContent },
            { "setShowPaintRects", &PageBackendDispatcher::setShowPaintRects },
            { "getScriptExecutionStatus", &PageBackendDispatcher::getScriptExecutionStatus },
            { "setScriptExecutionDisabled", &PageBackendDispatcher::setScriptExecutionDisabled },
            { "setTouchEmulationEnabled", &PageBackendDispatcher::setTouchEmulationEnabled },
            { "setEmulatedMedia", &PageBackendDispatcher::setEmulatedMedia },
            { "getCompositingBordersVisible", &PageBackendDispatcher::getCompositingBordersVisible },
            { "setCompositingBordersVisible", &PageBackendDispatcher::setCompositingBordersVisible },
            { "snapshotNode", &PageBackendDispatcher::snapshotNode },
            { "snapshotRect", &PageBackendDispatcher::snapshotRect },
            { "handleJavaScriptDialog", &PageBackendDispatcher::handleJavaScriptDialog },
            { "archive", &PageBackendDispatcher::archive },
        };
        size_t length = WTF_ARRAY_LENGTH(commands);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commands[i].name, commands[i].handler);
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::MethodNotFound, makeString('\'', "Page", '.', method, "' was not found"));
        return;
    }

    ((*this).*it->value)(callId, message.get());
}

void PageBackendDispatcher::enable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->enable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->enable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::disable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->disable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->disable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::addScriptToEvaluateOnLoad(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_scriptSource = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("scriptSource"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.addScriptToEvaluateOnLoad");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->addScriptToEvaluateOnLoad(callId, in_scriptSource);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    Inspector::Protocol::Page::ScriptIdentifier out_identifier;
    m_agent->addScriptToEvaluateOnLoad(error, in_scriptSource, &out_identifier);

    if (!error.length())
        result->setString(ASCIILiteral("identifier"), out_identifier);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::removeScriptToEvaluateOnLoad(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_identifier = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("identifier"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.removeScriptToEvaluateOnLoad");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->removeScriptToEvaluateOnLoad(callId, in_identifier);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->removeScriptToEvaluateOnLoad(error, in_identifier);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::reload(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    bool opt_in_ignoreCache_valueFound = false;
    bool opt_in_ignoreCache = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("ignoreCache"), &opt_in_ignoreCache_valueFound, protocolErrors.get());
    bool opt_in_scriptToEvaluateOnLoad_valueFound = false;
    String opt_in_scriptToEvaluateOnLoad = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("scriptToEvaluateOnLoad"), &opt_in_scriptToEvaluateOnLoad_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.reload");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->reload(callId, opt_in_ignoreCache_valueFound ? &opt_in_ignoreCache : nullptr, opt_in_scriptToEvaluateOnLoad_valueFound ? &opt_in_scriptToEvaluateOnLoad : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->reload(error, opt_in_ignoreCache_valueFound ? &opt_in_ignoreCache : nullptr, opt_in_scriptToEvaluateOnLoad_valueFound ? &opt_in_scriptToEvaluateOnLoad : nullptr);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::navigate(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_url = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("url"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.navigate");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->navigate(callId, in_url);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->navigate(error, in_url);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::getCookies(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getCookies(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Page::Cookie>> out_cookies;
    m_agent->getCookies(error, out_cookies);

    if (!error.length())
        result->setArray(ASCIILiteral("cookies"), out_cookies);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::deleteCookie(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_cookieName = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("cookieName"), nullptr, protocolErrors.get());
    String in_url = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("url"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.deleteCookie");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->deleteCookie(callId, in_cookieName, in_url);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->deleteCookie(error, in_cookieName, in_url);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::getResourceTree(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getResourceTree(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Page::FrameResourceTree> out_frameTree;
    m_agent->getResourceTree(error, out_frameTree);

    if (!error.length())
        result->setObject(ASCIILiteral("frameTree"), out_frameTree);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::getResourceContent(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_frameId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("frameId"), nullptr, protocolErrors.get());
    String in_url = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("url"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.getResourceContent");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getResourceContent(callId, in_frameId, in_url);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    String out_content;
    bool out_base64Encoded;
    m_agent->getResourceContent(error, in_frameId, in_url, &out_content, &out_base64Encoded);

    if (!error.length()) {
        result->setString(ASCIILiteral("content"), out_content);
        result->setBoolean(ASCIILiteral("base64Encoded"), out_base64Encoded);
    }
    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::searchInResource(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_frameId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("frameId"), nullptr, protocolErrors.get());
    String in_url = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("url"), nullptr, protocolErrors.get());
    String in_query = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("query"), nullptr, protocolErrors.get());
    bool opt_in_caseSensitive_valueFound = false;
    bool opt_in_caseSensitive = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("caseSensitive"), &opt_in_caseSensitive_valueFound, protocolErrors.get());
    bool opt_in_isRegex_valueFound = false;
    bool opt_in_isRegex = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("isRegex"), &opt_in_isRegex_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.searchInResource");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->searchInResource(callId, in_frameId, in_url, in_query, opt_in_caseSensitive_valueFound ? &opt_in_caseSensitive : nullptr, opt_in_isRegex_valueFound ? &opt_in_isRegex : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::GenericTypes::SearchMatch>> out_result;
    m_agent->searchInResource(error, in_frameId, in_url, in_query, opt_in_caseSensitive_valueFound ? &opt_in_caseSensitive : nullptr, opt_in_isRegex_valueFound ? &opt_in_isRegex : nullptr, out_result);

    if (!error.length())
        result->setArray(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::searchInResources(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_text = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("text"), nullptr, protocolErrors.get());
    bool opt_in_caseSensitive_valueFound = false;
    bool opt_in_caseSensitive = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("caseSensitive"), &opt_in_caseSensitive_valueFound, protocolErrors.get());
    bool opt_in_isRegex_valueFound = false;
    bool opt_in_isRegex = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("isRegex"), &opt_in_isRegex_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.searchInResources");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->searchInResources(callId, in_text, opt_in_caseSensitive_valueFound ? &opt_in_caseSensitive : nullptr, opt_in_isRegex_valueFound ? &opt_in_isRegex : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Page::SearchResult>> out_result;
    m_agent->searchInResources(error, in_text, opt_in_caseSensitive_valueFound ? &opt_in_caseSensitive : nullptr, opt_in_isRegex_valueFound ? &opt_in_isRegex : nullptr, out_result);

    if (!error.length())
        result->setArray(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::setDocumentContent(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_frameId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("frameId"), nullptr, protocolErrors.get());
    String in_html = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("html"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.setDocumentContent");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setDocumentContent(callId, in_frameId, in_html);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setDocumentContent(error, in_frameId, in_html);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::setShowPaintRects(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    bool in_result = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("result"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.setShowPaintRects");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setShowPaintRects(callId, in_result);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setShowPaintRects(error, in_result);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::getScriptExecutionStatus(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getScriptExecutionStatus(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    PageBackendDispatcherHandler::Result out_result;
    m_agent->getScriptExecutionStatus(error, &out_result);

    if (!error.length())
        result->setString(ASCIILiteral("result"), Inspector::Protocol::getEnumConstantValue(out_result));

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::setScriptExecutionDisabled(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    bool in_value = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("value"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.setScriptExecutionDisabled");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setScriptExecutionDisabled(callId, in_value);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setScriptExecutionDisabled(error, in_value);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::setTouchEmulationEnabled(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    bool in_enabled = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("enabled"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.setTouchEmulationEnabled");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setTouchEmulationEnabled(callId, in_enabled);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setTouchEmulationEnabled(error, in_enabled);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::setEmulatedMedia(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_media = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("media"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.setEmulatedMedia");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setEmulatedMedia(callId, in_media);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setEmulatedMedia(error, in_media);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::getCompositingBordersVisible(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getCompositingBordersVisible(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    bool out_result;
    m_agent->getCompositingBordersVisible(error, &out_result);

    if (!error.length())
        result->setBoolean(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::setCompositingBordersVisible(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    bool in_visible = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("visible"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.setCompositingBordersVisible");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setCompositingBordersVisible(callId, in_visible);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setCompositingBordersVisible(error, in_visible);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::snapshotNode(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_nodeId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("nodeId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.snapshotNode");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->snapshotNode(callId, in_nodeId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    String out_dataURL;
    m_agent->snapshotNode(error, in_nodeId, &out_dataURL);

    if (!error.length())
        result->setString(ASCIILiteral("dataURL"), out_dataURL);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::snapshotRect(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_x = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("x"), nullptr, protocolErrors.get());
    int in_y = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("y"), nullptr, protocolErrors.get());
    int in_width = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("width"), nullptr, protocolErrors.get());
    int in_height = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("height"), nullptr, protocolErrors.get());
    String in_coordinateSystem = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("coordinateSystem"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.snapshotRect");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->snapshotRect(callId, in_x, in_y, in_width, in_height, in_coordinateSystem);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    String out_dataURL;
    m_agent->snapshotRect(error, in_x, in_y, in_width, in_height, in_coordinateSystem, &out_dataURL);

    if (!error.length())
        result->setString(ASCIILiteral("dataURL"), out_dataURL);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::handleJavaScriptDialog(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    bool in_accept = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("accept"), nullptr, protocolErrors.get());
    bool opt_in_promptText_valueFound = false;
    String opt_in_promptText = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("promptText"), &opt_in_promptText_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Page.handleJavaScriptDialog");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->handleJavaScriptDialog(callId, in_accept, opt_in_promptText_valueFound ? &opt_in_promptText : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->handleJavaScriptDialog(error, in_accept, opt_in_promptText_valueFound ? &opt_in_promptText : nullptr);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void PageBackendDispatcher::archive(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->archive(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    String out_data;
    m_agent->archive(error, &out_data);

    if (!error.length())
        result->setString(ASCIILiteral("data"), out_data);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

Ref<RuntimeBackendDispatcher> RuntimeBackendDispatcher::create(BackendDispatcher* backendDispatcher, RuntimeBackendDispatcherHandler* agent)
{
    return adoptRef(*new RuntimeBackendDispatcher(*backendDispatcher, agent));
}

RuntimeBackendDispatcher::RuntimeBackendDispatcher(BackendDispatcher& backendDispatcher, RuntimeBackendDispatcherHandler* agent)
    : SupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    , m_alternateDispatcher(nullptr)
#endif
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Runtime"), this);
}

void RuntimeBackendDispatcher::dispatch(long callId, const String& method, Ref<InspectorObject>&& message)
{
    Ref<RuntimeBackendDispatcher> protect(*this);

    typedef void (RuntimeBackendDispatcher::*CallHandler)(long callId, const InspectorObject& message);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEPRECATED_DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, ());
    if (dispatchMap.isEmpty()) {
        static const struct MethodTable {
            const char* name;
            CallHandler handler;
        } commands[] = {
            { "parse", &RuntimeBackendDispatcher::parse },
            { "evaluate", &RuntimeBackendDispatcher::evaluate },
            { "callFunctionOn", &RuntimeBackendDispatcher::callFunctionOn },
            { "getProperties", &RuntimeBackendDispatcher::getProperties },
            { "getDisplayableProperties", &RuntimeBackendDispatcher::getDisplayableProperties },
            { "getCollectionEntries", &RuntimeBackendDispatcher::getCollectionEntries },
            { "saveResult", &RuntimeBackendDispatcher::saveResult },
            { "releaseObject", &RuntimeBackendDispatcher::releaseObject },
            { "releaseObjectGroup", &RuntimeBackendDispatcher::releaseObjectGroup },
            { "run", &RuntimeBackendDispatcher::run },
            { "enable", &RuntimeBackendDispatcher::enable },
            { "disable", &RuntimeBackendDispatcher::disable },
            { "getRuntimeTypesForVariablesAtOffsets", &RuntimeBackendDispatcher::getRuntimeTypesForVariablesAtOffsets },
            { "enableTypeProfiler", &RuntimeBackendDispatcher::enableTypeProfiler },
            { "disableTypeProfiler", &RuntimeBackendDispatcher::disableTypeProfiler },
            { "getBasicBlocks", &RuntimeBackendDispatcher::getBasicBlocks },
        };
        size_t length = WTF_ARRAY_LENGTH(commands);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commands[i].name, commands[i].handler);
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::MethodNotFound, makeString('\'', "Runtime", '.', method, "' was not found"));
        return;
    }

    ((*this).*it->value)(callId, message.get());
}

void RuntimeBackendDispatcher::parse(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_source = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("source"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Runtime.parse");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->parse(callId, in_source);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    Inspector::Protocol::Runtime::SyntaxErrorType out_result;
    Inspector::Protocol::OptOutput<String> out_message;
    RefPtr<Inspector::Protocol::Runtime::ErrorRange> out_range;
    m_agent->parse(error, in_source, &out_result, &out_message, out_range);

    if (!error.length()) {
        result->setString(ASCIILiteral("result"), Inspector::Protocol::getEnumConstantValue(out_result));
        if (out_message.isAssigned())
            result->setString(ASCIILiteral("message"), out_message.getValue());
        if (out_range)
            result->setObject(ASCIILiteral("range"), out_range);
    }
    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void RuntimeBackendDispatcher::evaluate(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_expression = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("expression"), nullptr, protocolErrors.get());
    bool opt_in_objectGroup_valueFound = false;
    String opt_in_objectGroup = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("objectGroup"), &opt_in_objectGroup_valueFound, protocolErrors.get());
    bool opt_in_includeCommandLineAPI_valueFound = false;
    bool opt_in_includeCommandLineAPI = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("includeCommandLineAPI"), &opt_in_includeCommandLineAPI_valueFound, protocolErrors.get());
    bool opt_in_doNotPauseOnExceptionsAndMuteConsole_valueFound = false;
    bool opt_in_doNotPauseOnExceptionsAndMuteConsole = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("doNotPauseOnExceptionsAndMuteConsole"), &opt_in_doNotPauseOnExceptionsAndMuteConsole_valueFound, protocolErrors.get());
    bool opt_in_contextId_valueFound = false;
    int opt_in_contextId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("contextId"), &opt_in_contextId_valueFound, protocolErrors.get());
    bool opt_in_returnByValue_valueFound = false;
    bool opt_in_returnByValue = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("returnByValue"), &opt_in_returnByValue_valueFound, protocolErrors.get());
    bool opt_in_generatePreview_valueFound = false;
    bool opt_in_generatePreview = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("generatePreview"), &opt_in_generatePreview_valueFound, protocolErrors.get());
    bool opt_in_saveResult_valueFound = false;
    bool opt_in_saveResult = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("saveResult"), &opt_in_saveResult_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Runtime.evaluate");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->evaluate(callId, in_expression, opt_in_objectGroup_valueFound ? &opt_in_objectGroup : nullptr, opt_in_includeCommandLineAPI_valueFound ? &opt_in_includeCommandLineAPI : nullptr, opt_in_doNotPauseOnExceptionsAndMuteConsole_valueFound ? &opt_in_doNotPauseOnExceptionsAndMuteConsole : nullptr, opt_in_contextId_valueFound ? &opt_in_contextId : nullptr, opt_in_returnByValue_valueFound ? &opt_in_returnByValue : nullptr, opt_in_generatePreview_valueFound ? &opt_in_generatePreview : nullptr, opt_in_saveResult_valueFound ? &opt_in_saveResult : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Runtime::RemoteObject> out_result;
    Inspector::Protocol::OptOutput<bool> out_wasThrown;
    Inspector::Protocol::OptOutput<int> out_savedResultIndex;
    m_agent->evaluate(error, in_expression, opt_in_objectGroup_valueFound ? &opt_in_objectGroup : nullptr, opt_in_includeCommandLineAPI_valueFound ? &opt_in_includeCommandLineAPI : nullptr, opt_in_doNotPauseOnExceptionsAndMuteConsole_valueFound ? &opt_in_doNotPauseOnExceptionsAndMuteConsole : nullptr, opt_in_contextId_valueFound ? &opt_in_contextId : nullptr, opt_in_returnByValue_valueFound ? &opt_in_returnByValue : nullptr, opt_in_generatePreview_valueFound ? &opt_in_generatePreview : nullptr, opt_in_saveResult_valueFound ? &opt_in_saveResult : nullptr, out_result, &out_wasThrown, &out_savedResultIndex);

    if (!error.length()) {
        result->setObject(ASCIILiteral("result"), out_result);
        if (out_wasThrown.isAssigned())
            result->setBoolean(ASCIILiteral("wasThrown"), out_wasThrown.getValue());
        if (out_savedResultIndex.isAssigned())
            result->setInteger(ASCIILiteral("savedResultIndex"), out_savedResultIndex.getValue());
    }
    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void RuntimeBackendDispatcher::callFunctionOn(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_objectId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("objectId"), nullptr, protocolErrors.get());
    String in_functionDeclaration = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("functionDeclaration"), nullptr, protocolErrors.get());
    bool opt_in_arguments_valueFound = false;
    RefPtr<Inspector::InspectorArray> opt_in_arguments = BackendDispatcher::getArray(paramsContainer.get(), ASCIILiteral("arguments"), &opt_in_arguments_valueFound, protocolErrors.get());
    bool opt_in_doNotPauseOnExceptionsAndMuteConsole_valueFound = false;
    bool opt_in_doNotPauseOnExceptionsAndMuteConsole = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("doNotPauseOnExceptionsAndMuteConsole"), &opt_in_doNotPauseOnExceptionsAndMuteConsole_valueFound, protocolErrors.get());
    bool opt_in_returnByValue_valueFound = false;
    bool opt_in_returnByValue = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("returnByValue"), &opt_in_returnByValue_valueFound, protocolErrors.get());
    bool opt_in_generatePreview_valueFound = false;
    bool opt_in_generatePreview = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("generatePreview"), &opt_in_generatePreview_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Runtime.callFunctionOn");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->callFunctionOn(callId, in_objectId, in_functionDeclaration, opt_in_arguments_valueFound ? opt_in_arguments.get() : nullptr, opt_in_doNotPauseOnExceptionsAndMuteConsole_valueFound ? &opt_in_doNotPauseOnExceptionsAndMuteConsole : nullptr, opt_in_returnByValue_valueFound ? &opt_in_returnByValue : nullptr, opt_in_generatePreview_valueFound ? &opt_in_generatePreview : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Runtime::RemoteObject> out_result;
    Inspector::Protocol::OptOutput<bool> out_wasThrown;
    m_agent->callFunctionOn(error, in_objectId, in_functionDeclaration, opt_in_arguments_valueFound ? opt_in_arguments.get() : nullptr, opt_in_doNotPauseOnExceptionsAndMuteConsole_valueFound ? &opt_in_doNotPauseOnExceptionsAndMuteConsole : nullptr, opt_in_returnByValue_valueFound ? &opt_in_returnByValue : nullptr, opt_in_generatePreview_valueFound ? &opt_in_generatePreview : nullptr, out_result, &out_wasThrown);

    if (!error.length()) {
        result->setObject(ASCIILiteral("result"), out_result);
        if (out_wasThrown.isAssigned())
            result->setBoolean(ASCIILiteral("wasThrown"), out_wasThrown.getValue());
    }
    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void RuntimeBackendDispatcher::getProperties(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_objectId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("objectId"), nullptr, protocolErrors.get());
    bool opt_in_ownProperties_valueFound = false;
    bool opt_in_ownProperties = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("ownProperties"), &opt_in_ownProperties_valueFound, protocolErrors.get());
    bool opt_in_generatePreview_valueFound = false;
    bool opt_in_generatePreview = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("generatePreview"), &opt_in_generatePreview_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Runtime.getProperties");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getProperties(callId, in_objectId, opt_in_ownProperties_valueFound ? &opt_in_ownProperties : nullptr, opt_in_generatePreview_valueFound ? &opt_in_generatePreview : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Runtime::PropertyDescriptor>> out_result;
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Runtime::InternalPropertyDescriptor>> out_internalProperties;
    m_agent->getProperties(error, in_objectId, opt_in_ownProperties_valueFound ? &opt_in_ownProperties : nullptr, opt_in_generatePreview_valueFound ? &opt_in_generatePreview : nullptr, out_result, out_internalProperties);

    if (!error.length()) {
        result->setArray(ASCIILiteral("result"), out_result);
        if (out_internalProperties)
            result->setArray(ASCIILiteral("internalProperties"), out_internalProperties);
    }
    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void RuntimeBackendDispatcher::getDisplayableProperties(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_objectId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("objectId"), nullptr, protocolErrors.get());
    bool opt_in_generatePreview_valueFound = false;
    bool opt_in_generatePreview = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("generatePreview"), &opt_in_generatePreview_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Runtime.getDisplayableProperties");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getDisplayableProperties(callId, in_objectId, opt_in_generatePreview_valueFound ? &opt_in_generatePreview : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Runtime::PropertyDescriptor>> out_properties;
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Runtime::InternalPropertyDescriptor>> out_internalProperties;
    m_agent->getDisplayableProperties(error, in_objectId, opt_in_generatePreview_valueFound ? &opt_in_generatePreview : nullptr, out_properties, out_internalProperties);

    if (!error.length()) {
        result->setArray(ASCIILiteral("properties"), out_properties);
        if (out_internalProperties)
            result->setArray(ASCIILiteral("internalProperties"), out_internalProperties);
    }
    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void RuntimeBackendDispatcher::getCollectionEntries(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_objectId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("objectId"), nullptr, protocolErrors.get());
    bool opt_in_objectGroup_valueFound = false;
    String opt_in_objectGroup = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("objectGroup"), &opt_in_objectGroup_valueFound, protocolErrors.get());
    bool opt_in_startIndex_valueFound = false;
    int opt_in_startIndex = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("startIndex"), &opt_in_startIndex_valueFound, protocolErrors.get());
    bool opt_in_numberToFetch_valueFound = false;
    int opt_in_numberToFetch = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("numberToFetch"), &opt_in_numberToFetch_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Runtime.getCollectionEntries");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getCollectionEntries(callId, in_objectId, opt_in_objectGroup_valueFound ? &opt_in_objectGroup : nullptr, opt_in_startIndex_valueFound ? &opt_in_startIndex : nullptr, opt_in_numberToFetch_valueFound ? &opt_in_numberToFetch : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Runtime::CollectionEntry>> out_entries;
    m_agent->getCollectionEntries(error, in_objectId, opt_in_objectGroup_valueFound ? &opt_in_objectGroup : nullptr, opt_in_startIndex_valueFound ? &opt_in_startIndex : nullptr, opt_in_numberToFetch_valueFound ? &opt_in_numberToFetch : nullptr, out_entries);

    if (!error.length())
        result->setArray(ASCIILiteral("entries"), out_entries);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void RuntimeBackendDispatcher::saveResult(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    RefPtr<Inspector::InspectorObject> in_value = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("value"), nullptr, protocolErrors.get());
    bool opt_in_contextId_valueFound = false;
    int opt_in_contextId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("contextId"), &opt_in_contextId_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Runtime.saveResult");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->saveResult(callId, *in_value, opt_in_contextId_valueFound ? &opt_in_contextId : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    Inspector::Protocol::OptOutput<int> out_savedResultIndex;
    m_agent->saveResult(error, *in_value, opt_in_contextId_valueFound ? &opt_in_contextId : nullptr, &out_savedResultIndex);

    if (!error.length())
        if (out_savedResultIndex.isAssigned())
            result->setInteger(ASCIILiteral("savedResultIndex"), out_savedResultIndex.getValue());

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void RuntimeBackendDispatcher::releaseObject(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_objectId = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("objectId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Runtime.releaseObject");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->releaseObject(callId, in_objectId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->releaseObject(error, in_objectId);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void RuntimeBackendDispatcher::releaseObjectGroup(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_objectGroup = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("objectGroup"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Runtime.releaseObjectGroup");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->releaseObjectGroup(callId, in_objectGroup);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->releaseObjectGroup(error, in_objectGroup);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void RuntimeBackendDispatcher::run(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->run(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->run(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void RuntimeBackendDispatcher::enable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->enable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->enable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void RuntimeBackendDispatcher::disable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->disable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->disable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void RuntimeBackendDispatcher::getRuntimeTypesForVariablesAtOffsets(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    RefPtr<Inspector::InspectorArray> in_locations = BackendDispatcher::getArray(paramsContainer.get(), ASCIILiteral("locations"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Runtime.getRuntimeTypesForVariablesAtOffsets");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getRuntimeTypesForVariablesAtOffsets(callId, *in_locations);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Runtime::TypeDescription>> out_types;
    m_agent->getRuntimeTypesForVariablesAtOffsets(error, *in_locations, out_types);

    if (!error.length())
        result->setArray(ASCIILiteral("types"), out_types);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void RuntimeBackendDispatcher::enableTypeProfiler(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->enableTypeProfiler(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->enableTypeProfiler(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void RuntimeBackendDispatcher::disableTypeProfiler(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->disableTypeProfiler(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->disableTypeProfiler(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void RuntimeBackendDispatcher::getBasicBlocks(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    String in_sourceID = BackendDispatcher::getString(paramsContainer.get(), ASCIILiteral("sourceID"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Runtime.getBasicBlocks");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->getBasicBlocks(callId, in_sourceID);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Runtime::BasicBlock>> out_basicBlocks;
    m_agent->getBasicBlocks(error, in_sourceID, out_basicBlocks);

    if (!error.length())
        result->setArray(ASCIILiteral("basicBlocks"), out_basicBlocks);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

Ref<TimelineBackendDispatcher> TimelineBackendDispatcher::create(BackendDispatcher* backendDispatcher, TimelineBackendDispatcherHandler* agent)
{
    return adoptRef(*new TimelineBackendDispatcher(*backendDispatcher, agent));
}

TimelineBackendDispatcher::TimelineBackendDispatcher(BackendDispatcher& backendDispatcher, TimelineBackendDispatcherHandler* agent)
    : SupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    , m_alternateDispatcher(nullptr)
#endif
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Timeline"), this);
}

void TimelineBackendDispatcher::dispatch(long callId, const String& method, Ref<InspectorObject>&& message)
{
    Ref<TimelineBackendDispatcher> protect(*this);

    if (method == "start")
        start(callId, message);
    else if (method == "stop")
        stop(callId, message);
    else
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::MethodNotFound, makeString('\'', "Timeline", '.', method, "' was not found"));
}

void TimelineBackendDispatcher::start(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    bool opt_in_maxCallStackDepth_valueFound = false;
    int opt_in_maxCallStackDepth = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("maxCallStackDepth"), &opt_in_maxCallStackDepth_valueFound, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Timeline.start");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->start(callId, opt_in_maxCallStackDepth_valueFound ? &opt_in_maxCallStackDepth : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->start(error, opt_in_maxCallStackDepth_valueFound ? &opt_in_maxCallStackDepth : nullptr);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void TimelineBackendDispatcher::stop(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->stop(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->stop(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

Ref<WorkerBackendDispatcher> WorkerBackendDispatcher::create(BackendDispatcher* backendDispatcher, WorkerBackendDispatcherHandler* agent)
{
    return adoptRef(*new WorkerBackendDispatcher(*backendDispatcher, agent));
}

WorkerBackendDispatcher::WorkerBackendDispatcher(BackendDispatcher& backendDispatcher, WorkerBackendDispatcherHandler* agent)
    : SupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    , m_alternateDispatcher(nullptr)
#endif
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Worker"), this);
}

void WorkerBackendDispatcher::dispatch(long callId, const String& method, Ref<InspectorObject>&& message)
{
    Ref<WorkerBackendDispatcher> protect(*this);

    typedef void (WorkerBackendDispatcher::*CallHandler)(long callId, const InspectorObject& message);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEPRECATED_DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, ());
    if (dispatchMap.isEmpty()) {
        static const struct MethodTable {
            const char* name;
            CallHandler handler;
        } commands[] = {
            { "enable", &WorkerBackendDispatcher::enable },
            { "disable", &WorkerBackendDispatcher::disable },
            { "sendMessageToWorker", &WorkerBackendDispatcher::sendMessageToWorker },
            { "canInspectWorkers", &WorkerBackendDispatcher::canInspectWorkers },
            { "connectToWorker", &WorkerBackendDispatcher::connectToWorker },
            { "disconnectFromWorker", &WorkerBackendDispatcher::disconnectFromWorker },
            { "setAutoconnectToWorkers", &WorkerBackendDispatcher::setAutoconnectToWorkers },
        };
        size_t length = WTF_ARRAY_LENGTH(commands);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commands[i].name, commands[i].handler);
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::MethodNotFound, makeString('\'', "Worker", '.', method, "' was not found"));
        return;
    }

    ((*this).*it->value)(callId, message.get());
}

void WorkerBackendDispatcher::enable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->enable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->enable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void WorkerBackendDispatcher::disable(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->disable(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->disable(error);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void WorkerBackendDispatcher::sendMessageToWorker(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_workerId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("workerId"), nullptr, protocolErrors.get());
    RefPtr<Inspector::InspectorObject> in_message = BackendDispatcher::getObject(paramsContainer.get(), ASCIILiteral("message"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Worker.sendMessageToWorker");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->sendMessageToWorker(callId, in_workerId, *in_message);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->sendMessageToWorker(error, in_workerId, *in_message);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void WorkerBackendDispatcher::canInspectWorkers(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->canInspectWorkers(callId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    bool out_result;
    m_agent->canInspectWorkers(error, &out_result);

    if (!error.length())
        result->setBoolean(ASCIILiteral("result"), out_result);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void WorkerBackendDispatcher::connectToWorker(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_workerId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("workerId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Worker.connectToWorker");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->connectToWorker(callId, in_workerId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->connectToWorker(error, in_workerId);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void WorkerBackendDispatcher::disconnectFromWorker(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    int in_workerId = BackendDispatcher::getInteger(paramsContainer.get(), ASCIILiteral("workerId"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Worker.disconnectFromWorker");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->disconnectFromWorker(callId, in_workerId);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->disconnectFromWorker(error, in_workerId);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

void WorkerBackendDispatcher::setAutoconnectToWorkers(long callId, const InspectorObject& message)
{
    auto protocolErrors = Inspector::Protocol::Array<String>::create();
    RefPtr<InspectorObject> paramsContainer;
    message.getObject(ASCIILiteral("params"), paramsContainer);
    bool in_value = BackendDispatcher::getBoolean(paramsContainer.get(), ASCIILiteral("value"), nullptr, protocolErrors.get());
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Worker.setAutoconnectToWorkers");
        m_backendDispatcher->reportProtocolError(&callId, BackendDispatcher::InvalidParams, errorMessage, WTF::move(protocolErrors));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->setAutoconnectToWorkers(callId, in_value);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    m_agent->setAutoconnectToWorkers(error, in_value);

    m_backendDispatcher->sendResponse(callId, WTF::move(result), error);
}

} // namespace Inspector
