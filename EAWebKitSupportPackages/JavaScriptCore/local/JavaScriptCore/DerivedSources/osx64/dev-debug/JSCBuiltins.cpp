/* Generated by generate-js-builtins do not hand edit. */

/*
 * Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>.
 * Copyright (C) 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014, 2015 Apple Inc. All rights reserved.
 * Copyright (C) 2015 Apple Inc. All rights reserved.
 * Copyright (C) 2015 Jordan Harband. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */



#include "config.h"

#include "JSCBuiltins.h"

#include "BuiltinExecutables.h"
#include "ConstructAbility.h"
#include "Executable.h"
#include "JSCellInlines.h"
#include "VM.h"

namespace JSC {

const char* s_arrayPrototypeReduceCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this === null)\n" \
    "        throw new @TypeError(\"Array.prototype.reduce requires that |this| not be null\");\n" \
    "\n" \
    "    if (this === undefined)\n" \
    "        throw new @TypeError(\"Array.prototype.reduce requires that |this| not be undefined\");\n" \
    "\n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"Array.prototype.reduce callback must be a function\");\n" \
    "\n" \
    "    if (length === 0 && arguments.length < 2)\n" \
    "        throw new @TypeError(\"reduce of empty array with no initial value\");\n" \
    "\n" \
    "    var accumulator, k = 0;\n" \
    "    if (arguments.length > 1)\n" \
    "        accumulator = arguments[1];\n" \
    "    else {\n" \
    "        while (k < length && !(k in array))\n" \
    "            k += 1;\n" \
    "        if (k >= length)\n" \
    "            throw new @TypeError(\"reduce of empty array with no initial value\");\n" \
    "        accumulator = array[k++];\n" \
    "    }\n" \
    "\n" \
    "    while (k < length) {\n" \
    "        if (k in array)\n" \
    "            accumulator = callback.@call(undefined, accumulator, array[k], k, array);\n" \
    "        k += 1;\n" \
    "    }\n" \
    "    return accumulator;\n" \
    "})\n" \
;

const int s_arrayPrototypeReduceCodeLength = 1101;

const ConstructAbility s_arrayPrototypeReduceCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_arrayPrototypeReduceRightCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this === null)\n" \
    "        throw new @TypeError(\"Array.prototype.reduceRight requires that |this| not be null\");\n" \
    "\n" \
    "    if (this === undefined)\n" \
    "        throw new @TypeError(\"Array.prototype.reduceRight requires that |this| not be undefined\");\n" \
    "\n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"Array.prototype.reduceRight callback must be a function\");\n" \
    "\n" \
    "    if (length === 0 && arguments.length < 2)\n" \
    "        throw new @TypeError(\"reduceRight of empty array with no initial value\");\n" \
    "\n" \
    "    var accumulator, k = length - 1;\n" \
    "    if (arguments.length > 1)\n" \
    "        accumulator = arguments[1];\n" \
    "    else {\n" \
    "        while (k >= 0 && !(k in array))\n" \
    "            k -= 1;\n" \
    "        if (k < 0)\n" \
    "            throw new @TypeError(\"reduceRight of empty array with no initial value\");\n" \
    "        accumulator = array[k--];\n" \
    "    }\n" \
    "\n" \
    "    while (k >= 0) {\n" \
    "        if (k in array)\n" \
    "            accumulator = callback.@call(undefined, accumulator, array[k], k, array);\n" \
    "        k -= 1;\n" \
    "    }\n" \
    "    return accumulator;\n" \
    "})\n" \
;

const int s_arrayPrototypeReduceRightCodeLength = 1121;

const ConstructAbility s_arrayPrototypeReduceRightCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_arrayPrototypeEveryCode =
    "(function (callback ) {\n" \
    "    \"use strict\";\n" \
    "    if (this === null)\n" \
    "        throw new @TypeError(\"Array.prototype.every requires that |this| not be null\");\n" \
    "    \n" \
    "    if (this === undefined)\n" \
    "        throw new @TypeError(\"Array.prototype.every requires that |this| not be undefined\");\n" \
    "    \n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"Array.prototype.every callback must be a function\");\n" \
    "    \n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : undefined;\n" \
    "    \n" \
    "    for (var i = 0; i < length; i++) {\n" \
    "        if (!(i in array))\n" \
    "            continue;\n" \
    "        if (!callback.@call(thisArg, array[i], i, array))\n" \
    "            return false;\n" \
    "    }\n" \
    "    \n" \
    "    return true;\n" \
    "})\n" \
;

const int s_arrayPrototypeEveryCodeLength = 761;

const ConstructAbility s_arrayPrototypeEveryCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_arrayPrototypeForEachCode =
    "(function (callback ) {\n" \
    "    \"use strict\";\n" \
    "    if (this === null)\n" \
    "        throw new @TypeError(\"Array.prototype.forEach requires that |this| not be null\");\n" \
    "    \n" \
    "    if (this === undefined)\n" \
    "        throw new @TypeError(\"Array.prototype.forEach requires that |this| not be undefined\");\n" \
    "    \n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"Array.prototype.forEach callback must be a function\");\n" \
    "    \n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : undefined;\n" \
    "    \n" \
    "    for (var i = 0; i < length; i++) {\n" \
    "        if (i in array)\n" \
    "            callback.@call(thisArg, array[i], i, array);\n" \
    "    }\n" \
    "})\n" \
;

const int s_arrayPrototypeForEachCodeLength = 693;

const ConstructAbility s_arrayPrototypeForEachCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_arrayPrototypeFilterCode =
    "(function (callback ) {\n" \
    "    \"use strict\";\n" \
    "    if (this === null)\n" \
    "        throw new @TypeError(\"Array.prototype.filter requires that |this| not be null\");\n" \
    "    \n" \
    "    if (this === undefined)\n" \
    "        throw new @TypeError(\"Array.prototype.filter requires that |this| not be undefined\");\n" \
    "    \n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"Array.prototype.filter callback must be a function\");\n" \
    "    \n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : undefined;\n" \
    "    var result = [];\n" \
    "    var nextIndex = 0;\n" \
    "    for (var i = 0; i < length; i++) {\n" \
    "        if (!(i in array))\n" \
    "            continue;\n" \
    "        var current = array[i]\n" \
    "        if (callback.@call(thisArg, current, i, array)) {\n" \
    "            @putByValDirect(result, nextIndex, current);\n" \
    "            ++nextIndex;\n" \
    "        }\n" \
    "    }\n" \
    "    return result;\n" \
    "})\n" \
;

const int s_arrayPrototypeFilterCodeLength = 897;

const ConstructAbility s_arrayPrototypeFilterCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_arrayPrototypeMapCode =
    "(function (callback ) {\n" \
    "    \"use strict\";\n" \
    "    if (this === null)\n" \
    "        throw new @TypeError(\"Array.prototype.map requires that |this| not be null\");\n" \
    "    \n" \
    "    if (this === undefined)\n" \
    "        throw new @TypeError(\"Array.prototype.map requires that |this| not be undefined\");\n" \
    "    \n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"Array.prototype.map callback must be a function\");\n" \
    "    \n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : undefined;\n" \
    "    var result = [];\n" \
    "    result.length = length;\n" \
    "    var nextIndex = 0;\n" \
    "    for (var i = 0; i < length; i++) {\n" \
    "        if (!(i in array))\n" \
    "            continue;\n" \
    "        var mappedValue = callback.@call(thisArg, array[i], i, array);\n" \
    "        @putByValDirect(result, i, mappedValue);\n" \
    "    }\n" \
    "    return result;\n" \
    "})\n" \
;

const int s_arrayPrototypeMapCodeLength = 855;

const ConstructAbility s_arrayPrototypeMapCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_arrayPrototypeSomeCode =
    "(function (callback ) {\n" \
    "    \"use strict\";\n" \
    "    if (this === null)\n" \
    "        throw new @TypeError(\"Array.prototype.some requires that |this| not be null\");\n" \
    "    \n" \
    "    if (this === undefined)\n" \
    "        throw new @TypeError(\"Array.prototype.some requires that |this| not be undefined\");\n" \
    "    \n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"Array.prototype.some callback must be a function\");\n" \
    "    \n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : undefined;\n" \
    "    for (var i = 0; i < length; i++) {\n" \
    "        if (!(i in array))\n" \
    "            continue;\n" \
    "        if (callback.@call(thisArg, array[i], i, array))\n" \
    "            return true;\n" \
    "    }\n" \
    "    return false;\n" \
    "})\n" \
;

const int s_arrayPrototypeSomeCodeLength = 747;

const ConstructAbility s_arrayPrototypeSomeCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_arrayPrototypeFillCode =
    "(function (value )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this === null)\n" \
    "        throw new @TypeError(\"Array.prototype.fill requires that |this| not be null\");\n" \
    "    \n" \
    "    if (this === undefined)\n" \
    "        throw new @TypeError(\"Array.prototype.fill requires that |this| not be undefined\");\n" \
    "    var O = @Object(this);\n" \
    "    var len = @toLength(O.length);\n" \
    "    var relativeStart = 0;\n" \
    "    if (arguments.length > 1 && arguments[1] !== undefined)\n" \
    "        relativeStart = arguments[1] | 0;\n" \
    "    var k = 0;\n" \
    "    if (relativeStart < 0) {\n" \
    "        k = len + relativeStart;\n" \
    "        if (k < 0)\n" \
    "            k = 0;\n" \
    "    } else {\n" \
    "        k = relativeStart;\n" \
    "        if (k > len)\n" \
    "            k = len;\n" \
    "    }\n" \
    "    var relativeEnd = len;\n" \
    "    if (arguments.length > 2 && arguments[2] !== undefined)\n" \
    "        relativeEnd = arguments[2] | 0;\n" \
    "    var final = 0;\n" \
    "    if (relativeEnd < 0) {\n" \
    "        final = len + relativeEnd;\n" \
    "        if (final < 0)\n" \
    "            final = 0;\n" \
    "    } else {\n" \
    "        final = relativeEnd;\n" \
    "        if (final > len)\n" \
    "            final = len;\n" \
    "    }\n" \
    "    for (; k < final; k++)\n" \
    "        O[k] = value;\n" \
    "    return O;\n" \
    "})\n" \
;

const int s_arrayPrototypeFillCodeLength = 1086;

const ConstructAbility s_arrayPrototypeFillCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_arrayPrototypeFindCode =
    "(function (callback ) {\n" \
    "    \"use strict\";\n" \
    "    if (this === null)\n" \
    "        throw new @TypeError(\"Array.prototype.find requires that |this| not be null\");\n" \
    "    \n" \
    "    if (this === undefined)\n" \
    "        throw new @TypeError(\"Array.prototype.find requires that |this| not be undefined\");\n" \
    "    \n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"Array.prototype.find callback must be a function\");\n" \
    "    \n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : undefined;\n" \
    "    for (var i = 0; i < length; i++) {\n" \
    "        var kValue = array[i];\n" \
    "        if (callback.@call(thisArg, kValue, i, array))\n" \
    "            return kValue;\n" \
    "    }\n" \
    "    return undefined;\n" \
    "})\n" \
;

const int s_arrayPrototypeFindCodeLength = 733;

const ConstructAbility s_arrayPrototypeFindCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_arrayPrototypeFindIndexCode =
    "(function (callback ) {\n" \
    "    \"use strict\";\n" \
    "    if (this === null)\n" \
    "        throw new @TypeError(\"Array.prototype.findIndex requires that |this| not be null\");\n" \
    "    \n" \
    "    if (this === undefined)\n" \
    "        throw new @TypeError(\"Array.prototype.findIndex requires that |this| not be undefined\");\n" \
    "    \n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"Array.prototype.findIndex callback must be a function\");\n" \
    "    \n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : undefined;\n" \
    "    for (var i = 0; i < length; i++) {\n" \
    "        if (callback.@call(thisArg, array[i], i, array))\n" \
    "            return i;\n" \
    "    }\n" \
    "    return -1;\n" \
    "})\n" \
;

const int s_arrayPrototypeFindIndexCodeLength = 707;

const ConstructAbility s_arrayPrototypeFindIndexCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_arrayPrototypeIncludesCode =
    "(function (searchElement ) {\n" \
    "    \"use strict\";\n" \
    "    if (this === null)\n" \
    "        throw new @TypeError(\"Array.prototype.includes requires that |this| not be null\");\n" \
    "\n" \
    "    if (this === undefined)\n" \
    "        throw new @TypeError(\"Array.prototype.includes requires that |this| not be undefined\");\n" \
    "\n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "\n" \
    "    if (length === 0)\n" \
    "        return false;\n" \
    "\n" \
    "    var fromIndex = 0;\n" \
    "    if (arguments.length > 1 && arguments[1] !== undefined)\n" \
    "        fromIndex = arguments[1] | 0;\n" \
    "\n" \
    "    var index;\n" \
    "    if (fromIndex >= 0)\n" \
    "        index = fromIndex;\n" \
    "    else\n" \
    "        index = length + fromIndex;\n" \
    "\n" \
    "    if (index < 0)\n" \
    "        index = 0;\n" \
    "\n" \
    "    var currentElement;\n" \
    "    for (; index < length; ++index) {\n" \
    "        currentElement = array[index];\n" \
    "        //\n" \
    "        if (searchElement === currentElement || (searchElement !== searchElement && currentElement !== currentElement))\n" \
    "            return true;\n" \
    "    }\n" \
    "    return false;\n" \
    "})\n" \
;

const int s_arrayPrototypeIncludesCodeLength = 963;

const ConstructAbility s_arrayPrototypeIncludesCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_arrayPrototypeSortCode =
    "(function (comparator)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    function min(a, b)\n" \
    "    {\n" \
    "        return a < b ? a : b;\n" \
    "    }\n" \
    "\n" \
    "    function stringComparator(a, b)\n" \
    "    {\n" \
    "        var aString = a.string;\n" \
    "        var bString = b.string;\n" \
    "\n" \
    "        var aLength = aString.length;\n" \
    "        var bLength = bString.length;\n" \
    "        var length = min(aLength, bLength);\n" \
    "\n" \
    "        for (var i = 0; i < length; ++i) {\n" \
    "            var aCharCode = aString.@charCodeAt(i);\n" \
    "            var bCharCode = bString.@charCodeAt(i);\n" \
    "\n" \
    "            if (aCharCode == bCharCode)\n" \
    "                continue;\n" \
    "\n" \
    "            return aCharCode - bCharCode;\n" \
    "        }\n" \
    "\n" \
    "        return aLength - bLength;\n" \
    "    }\n" \
    "\n" \
    "    //\n" \
    "    function compactSparse(array, dst, src, length)\n" \
    "    {\n" \
    "        var values = [ ];\n" \
    "        var seen = { };\n" \
    "        var valueCount = 0;\n" \
    "        var undefinedCount = 0;\n" \
    "\n" \
    "        //\n" \
    "        for (var i = dst; i < src; ++i)\n" \
    "            delete array[i];\n" \
    "\n" \
    "        for (var object = array; object; object = @Object.@getPrototypeOf(object)) {\n" \
    "            var propertyNames = @Object.@getOwnPropertyNames(object);\n" \
    "            for (var i = 0; i < propertyNames.length; ++i) {\n" \
    "                var index = propertyNames[i];\n" \
    "                if (index < length) { //\n" \
    "                    if (seen[index]) //\n" \
    "                        continue;\n" \
    "                    seen[index] = 1;\n" \
    "\n" \
    "                    var value = array[index];\n" \
    "                    delete array[index];\n" \
    "\n" \
    "                    if (value === undefined) {\n" \
    "                        ++undefinedCount;\n" \
    "                        continue;\n" \
    "                    }\n" \
    "\n" \
    "                    array[valueCount++] = value;\n" \
    "                }\n" \
    "            }\n" \
    "        }\n" \
    "\n" \
    "        for (var i = valueCount; i < valueCount + undefinedCount; ++i)\n" \
    "            array[i] = undefined;\n" \
    "\n" \
    "        return valueCount;\n" \
    "    }\n" \
    "\n" \
    "    function compactSlow(array, length)\n" \
    "    {\n" \
    "        var holeCount = 0;\n" \
    "\n" \
    "        for (var dst = 0, src = 0; src < length; ++src) {\n" \
    "            if (!(src in array)) {\n" \
    "                ++holeCount;\n" \
    "                if (holeCount < 256)\n" \
    "                    continue;\n" \
    "                return compactSparse(array, dst, src, length);\n" \
    "            }\n" \
    "\n" \
    "            var value = array[src];\n" \
    "            if (value === undefined)\n" \
    "                continue;\n" \
    "\n" \
    "            array[dst++] = value;\n" \
    "        }\n" \
    "\n" \
    "        var valueCount = dst;\n" \
    "        var undefinedCount = length - valueCount - holeCount;\n" \
    "\n" \
    "        for (var i = valueCount; i < valueCount + undefinedCount; ++i)\n" \
    "            array[i] = undefined;\n" \
    "\n" \
    "        for (var i = valueCount + undefinedCount; i < length; ++i)\n" \
    "            delete array[i];\n" \
    "\n" \
    "        return valueCount;\n" \
    "    }\n" \
    "\n" \
    "    //\n" \
    "    function compact(array, length)\n" \
    "    {\n" \
    "        for (var i = 0; i < array.length; ++i) {\n" \
    "            if (array[i] === undefined)\n" \
    "                return compactSlow(array, length);\n" \
    "        }\n" \
    "\n" \
    "        return length;\n" \
    "    }\n" \
    "\n" \
    "    function merge(dst, src, srcIndex, srcEnd, width, comparator)\n" \
    "    {\n" \
    "        var left = srcIndex;\n" \
    "        var leftEnd = min(left + width, srcEnd);\n" \
    "        var right = leftEnd;\n" \
    "        var rightEnd = min(right + width, srcEnd);\n" \
    "\n" \
    "        for (var dstIndex = left; dstIndex < rightEnd; ++dstIndex) {\n" \
    "            if (right < rightEnd) {\n" \
    "                if (left >= leftEnd || comparator(src[right], src[left]) < 0) {\n" \
    "                    dst[dstIndex] = src[right++];\n" \
    "                    continue;\n" \
    "                }\n" \
    "            }\n" \
    "\n" \
    "            dst[dstIndex] = src[left++];\n" \
    "        }\n" \
    "    }\n" \
    "\n" \
    "    function mergeSort(array, valueCount, comparator)\n" \
    "    {\n" \
    "        var buffer = [ ];\n" \
    "        buffer.length = valueCount;\n" \
    "\n" \
    "        var dst = buffer;\n" \
    "        var src = array;\n" \
    "        for (var width = 1; width < valueCount; width *= 2) {\n" \
    "            for (var srcIndex = 0; srcIndex < valueCount; srcIndex += 2 * width)\n" \
    "                merge(dst, src, srcIndex, valueCount, width, comparator);\n" \
    "\n" \
    "            var tmp = src;\n" \
    "            src = dst;\n" \
    "            dst = tmp;\n" \
    "        }\n" \
    "\n" \
    "        if (src != array) {\n" \
    "            for(var i = 0; i < valueCount; i++)\n" \
    "                array[i] = src[i];\n" \
    "        }\n" \
    "    }\n" \
    "\n" \
    "    function bucketSort(array, dst, bucket, depth)\n" \
    "    {\n" \
    "        if (bucket.length < 32 || depth > 32) {\n" \
    "            mergeSort(bucket, bucket.length, stringComparator);\n" \
    "            for (var i = 0; i < bucket.length; ++i)\n" \
    "                array[dst++] = bucket[i].value;\n" \
    "            return dst;\n" \
    "        }\n" \
    "\n" \
    "        var buckets = [ ];\n" \
    "        for (var i = 0; i < bucket.length; ++i) {\n" \
    "            var entry = bucket[i];\n" \
    "            var string = entry.string;\n" \
    "            if (string.length == depth) {\n" \
    "                array[dst++] = entry.value;\n" \
    "                continue;\n" \
    "            }\n" \
    "\n" \
    "            var c = string.@charCodeAt(depth);\n" \
    "            if (!buckets[c])\n" \
    "                buckets[c] = [ ];\n" \
    "            buckets[c][buckets[c].length] = entry;\n" \
    "        }\n" \
    "\n" \
    "        for (var i = 0; i < buckets.length; ++i) {\n" \
    "            if (!buckets[i])\n" \
    "                continue;\n" \
    "            dst = bucketSort(array, dst, buckets[i], depth + 1);\n" \
    "        }\n" \
    "\n" \
    "        return dst;\n" \
    "    }\n" \
    "\n" \
    "    function comparatorSort(array, comparator)\n" \
    "    {\n" \
    "        var length = array.length >>> 0;\n" \
    "\n" \
    "        //\n" \
    "        //\n" \
    "        if (length < 2)\n" \
    "            return;\n" \
    "\n" \
    "        var valueCount = compact(array, length);\n" \
    "        mergeSort(array, valueCount, comparator);\n" \
    "    }\n" \
    "\n" \
    "    function stringSort(array)\n" \
    "    {\n" \
    "        var length = array.length >>> 0;\n" \
    "\n" \
    "        //\n" \
    "        //\n" \
    "        if (length < 2)\n" \
    "            return;\n" \
    "\n" \
    "        var valueCount = compact(array, length);\n" \
    "\n" \
    "        var strings = new @Array(valueCount);\n" \
    "        for (var i = 0; i < valueCount; ++i)\n" \
    "            strings[i] = { string: @toString(array[i]), value: array[i] };\n" \
    "\n" \
    "        bucketSort(array, 0, strings, 0);\n" \
    "    }\n" \
    "\n" \
    "    if (this === null)\n" \
    "        throw new @TypeError(\"Array.prototype.sort requires that |this| not be null\");\n" \
    "\n" \
    "    if (this === undefined)\n" \
    "        throw new @TypeError(\"Array.prototype.sort requires that |this| not be undefined\");\n" \
    "\n" \
    "    if (typeof this == \"string\")\n" \
    "        throw new @TypeError(\"Attempted to assign to readonly property.\");\n" \
    "\n" \
    "    var array = @Object(this);\n" \
    "\n" \
    "    if (typeof comparator == \"function\")\n" \
    "        comparatorSort(array, comparator);\n" \
    "    else\n" \
    "        stringSort(array);\n" \
    "\n" \
    "    return array;\n" \
    "})\n" \
;

const int s_arrayPrototypeSortCodeLength = 6180;

const ConstructAbility s_arrayPrototypeSortCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_arrayPrototypeCopyWithinCode =
    "(function (target, start )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    function maxWithPositives(a, b)\n" \
    "    {\n" \
    "        return (a < b) ? b : a;\n" \
    "    }\n" \
    "\n" \
    "    function minWithMaybeNegativeZeroAndPositive(maybeNegativeZero, positive)\n" \
    "    {\n" \
    "        return (maybeNegativeZero < positive) ? maybeNegativeZero : positive;\n" \
    "    }\n" \
    "\n" \
    "    if (this === null || this === undefined)\n" \
    "        throw new @TypeError(\"Array.copyWithin requires that |this| not be null or undefined\");\n" \
    "    var thisObject = @Object(this);\n" \
    "\n" \
    "    var length = @toLength(thisObject.length);\n" \
    "\n" \
    "    var relativeTarget = @toInteger(target);\n" \
    "    var to = (relativeTarget < 0) ? maxWithPositives(length + relativeTarget, 0) : minWithMaybeNegativeZeroAndPositive(relativeTarget, length);\n" \
    "\n" \
    "    var relativeStart = @toInteger(start);\n" \
    "    var from = (relativeStart < 0) ? maxWithPositives(length + relativeStart, 0) : minWithMaybeNegativeZeroAndPositive(relativeStart, length);\n" \
    "\n" \
    "    var relativeEnd;\n" \
    "    if (arguments.length >= 3) {\n" \
    "        var end = arguments[2];\n" \
    "        if (end === undefined)\n" \
    "            relativeEnd = length;\n" \
    "        else\n" \
    "            relativeEnd = @toInteger(end);\n" \
    "    } else\n" \
    "        relativeEnd = length;\n" \
    "\n" \
    "    var finalValue = (relativeEnd < 0) ? maxWithPositives(length + relativeEnd, 0) : minWithMaybeNegativeZeroAndPositive(relativeEnd, length);\n" \
    "\n" \
    "    var count = minWithMaybeNegativeZeroAndPositive(finalValue - from, length - to);\n" \
    "\n" \
    "    var direction = 1;\n" \
    "    if (from < to && to < from + count) {\n" \
    "        direction = -1;\n" \
    "        from = from + count - 1;\n" \
    "        to = to + count - 1;\n" \
    "    }\n" \
    "\n" \
    "    for (var i = 0; i < count; ++i, from += direction, to += direction) {\n" \
    "        if (from in thisObject)\n" \
    "            thisObject[to] = thisObject[from];\n" \
    "        else\n" \
    "            delete thisObject[to];\n" \
    "    }\n" \
    "\n" \
    "    return thisObject;\n" \
    "})\n" \
;

const int s_arrayPrototypeCopyWithinCodeLength = 1772;

const ConstructAbility s_arrayPrototypeCopyWithinCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_arrayConstructorOfCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var length = arguments.length;\n" \
    "    //\n" \
    "    var array = typeof this === 'function' ? new this(length) : new @Array(length);\n" \
    "    for (var k = 0; k < length; ++k)\n" \
    "        @putByValDirect(array, k, arguments[k]);\n" \
    "    array.length = length;\n" \
    "    return array;\n" \
    "})\n" \
;

const int s_arrayConstructorOfCodeLength = 294;

const ConstructAbility s_arrayConstructorOfCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_arrayConstructorFromCode =
    "(function (items ) {\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var thisObj = this;\n" \
    "\n" \
    "    var mapFn = arguments.length > 1 ? arguments[1] : undefined;\n" \
    "\n" \
    "    var thisArg;\n" \
    "\n" \
    "    if (mapFn !== undefined) {\n" \
    "        if (typeof mapFn !== \"function\")\n" \
    "            throw new @TypeError(\"Array.from requires that the second argument, when provided, be a function\");\n" \
    "\n" \
    "        if (arguments.length > 2)\n" \
    "            thisArg = arguments[2];\n" \
    "    }\n" \
    "\n" \
    "    if (items == null)\n" \
    "        throw new @TypeError(\"Array.from requires an array-like object - not null or undefined\");\n" \
    "\n" \
    "    var iteratorMethod = items[@symbolIterator];\n" \
    "    if (iteratorMethod != null) {\n" \
    "        if (typeof iteratorMethod !== \"function\")\n" \
    "            throw new @TypeError(\"Array.from requires that the property of the first argument, items[Symbol.iterator], when exists, be a function\");\n" \
    "\n" \
    "        //\n" \
    "        var result = (typeof thisObj === \"function\") ? @Object(new thisObj()) : [];\n" \
    "\n" \
    "        var k = 0;\n" \
    "        var iterator = iteratorMethod.@call(items);\n" \
    "\n" \
    "        //\n" \
    "        //\n" \
    "        //\n" \
    "        var wrapper = {\n" \
    "            [@symbolIterator]() {\n" \
    "                return iterator;\n" \
    "            }\n" \
    "        };\n" \
    "\n" \
    "        for (var value of wrapper) {\n" \
    "            if (mapFn)\n" \
    "                @putByValDirect(result, k, thisArg === undefined ? mapFn(value, k) : mapFn.@call(thisArg, value, k));\n" \
    "            else\n" \
    "                @putByValDirect(result, k, value);\n" \
    "            k += 1;\n" \
    "        }\n" \
    "\n" \
    "        result.length = k;\n" \
    "        return result;\n" \
    "    }\n" \
    "\n" \
    "    var arrayLike = @Object(items);\n" \
    "    var arrayLikeLength = @toLength(arrayLike.length);\n" \
    "\n" \
    "    //\n" \
    "    var result = (typeof thisObj === \"function\") ? @Object(new thisObj(arrayLikeLength)) : new @Array(arrayLikeLength);\n" \
    "\n" \
    "    var k = 0;\n" \
    "    while (k < arrayLikeLength) {\n" \
    "        var value = arrayLike[k];\n" \
    "        if (mapFn)\n" \
    "            @putByValDirect(result, k, thisArg === undefined ? mapFn(value, k) : mapFn.@call(thisArg, value, k));\n" \
    "        else\n" \
    "            @putByValDirect(result, k, value);\n" \
    "        k += 1;\n" \
    "    }\n" \
    "\n" \
    "    result.length = arrayLikeLength;\n" \
    "    return result;\n" \
    "})\n" \
;

const int s_arrayConstructorFromCodeLength = 2046;

const ConstructAbility s_arrayConstructorFromCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_arrayIteratorPrototypeNextCode =
    "(function () {\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"%ArrayIteratorPrototype%.next requires that |this| not be null or undefined\");\n" \
    "\n" \
    "    var itemKind = this.@arrayIterationKind;\n" \
    "    if (itemKind === undefined)\n" \
    "        throw new @TypeError(\"%ArrayIteratorPrototype%.next requires that |this| be an Array Iterator instance\");\n" \
    "\n" \
    "    var done = true;\n" \
    "    var value = undefined;\n" \
    "\n" \
    "    var array = this.@iteratedObject;\n" \
    "    if (array !== undefined) {\n" \
    "        var index = this.@arrayIteratorNextIndex;\n" \
    "        var length = array.length >>> 0;\n" \
    "        if (index >= length) {\n" \
    "            this.@iteratedObject = undefined;\n" \
    "        } else {\n" \
    "            this.@arrayIteratorNextIndex = index + 1;\n" \
    "            done = false;\n" \
    "            if (itemKind === @arrayIterationKindKey) {\n" \
    "                value = index;\n" \
    "            } else if (itemKind === @arrayIterationKindValue) {\n" \
    "                value = array[index];\n" \
    "            } else {\n" \
    "                value = [ index, array[index] ];\n" \
    "            }\n" \
    "        }\n" \
    "    }\n" \
    "\n" \
    "    return {done, value};\n" \
    "})\n" \
;

const int s_arrayIteratorPrototypeNextCodeLength = 1059;

const ConstructAbility s_arrayIteratorPrototypeNextCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_functionPrototypeCallCode =
    "(function (thisArgument) {\n" \
    "    \"use strict\";\n" \
    "    return this.@call(...arguments);\n" \
    "})\n" \
;

const int s_functionPrototypeCallCodeLength = 85;

const ConstructAbility s_functionPrototypeCallCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_functionPrototypeApplyCode =
    "(function (thisValue, argumentValues) {\n" \
    "    \"use strict\";\n" \
    "    return this.@apply(thisValue, argumentValues);\n" \
    "})\n" \
;

const int s_functionPrototypeApplyCodeLength = 112;

const ConstructAbility s_functionPrototypeApplyCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_globalObjectToIntegerCode =
    "(function (target)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var numberValue = @Number(target);\n" \
    "\n" \
    "    //\n" \
    "    if (numberValue !== numberValue)\n" \
    "        return 0;\n" \
    "\n" \
    "    if (numberValue === 0 || !@isFinite(numberValue))\n" \
    "        return numberValue;\n" \
    "\n" \
    "    return (numberValue > 0 ? 1 : -1) * @floor(@abs(numberValue));\n" \
    "})\n" \
;

const int s_globalObjectToIntegerCodeLength = 296;

const ConstructAbility s_globalObjectToIntegerCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_globalObjectToLengthCode =
    "(function (target)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var maxSafeInteger = 0x1FFFFFFFFFFFFF;\n" \
    "    var length = @toInteger(target);\n" \
    "    //\n" \
    "    return length > 0 ? (length < maxSafeInteger ? length : maxSafeInteger) : 0;\n" \
    "})\n" \
;

const int s_globalObjectToLengthCodeLength = 211;

const ConstructAbility s_globalObjectToLengthCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_globalObjectIsObjectCode =
    "(function (object)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    return (object !== null && typeof object === \"object\") || typeof object === \"function\";\n" \
    "})\n" \
;

const int s_globalObjectIsObjectCodeLength = 135;

const ConstructAbility s_globalObjectIsObjectCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_inspectorInstrumentationObjectPromiseFulfilledCode =
    "(function (promise, value, reactions)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    if (!this.isEnabled)\n" \
    "        return;\n" \
    "})\n" \
;

const int s_inspectorInstrumentationObjectPromiseFulfilledCodeLength = 103;

const ConstructAbility s_inspectorInstrumentationObjectPromiseFulfilledCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_inspectorInstrumentationObjectPromiseRejectedCode =
    "(function (promise, reason, reactions)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    if (!this.isEnabled)\n" \
    "        return;\n" \
    "})\n" \
;

const int s_inspectorInstrumentationObjectPromiseRejectedCodeLength = 104;

const ConstructAbility s_inspectorInstrumentationObjectPromiseRejectedCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_iteratorPrototypeSymbolIteratorCode =
    "(function ()\n" \
    "{\n" \
    "    'use strict';\n" \
    "    return this;\n" \
    "})\n" \
;

const int s_iteratorPrototypeSymbolIteratorCodeLength = 53;

const ConstructAbility s_iteratorPrototypeSymbolIteratorCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_objectConstructorAssignCode =
    "(function (target, sources) {\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    if (target == null)\n" \
    "        throw new @TypeError(\"can't convert \" + target + \" to object\");\n" \
    "\n" \
    "    var objTarget = @Object(target);\n" \
    "    for (var s = 1, argumentsLength = arguments.length; s < argumentsLength; ++s) {\n" \
    "        var nextSource = arguments[s];\n" \
    "        if (nextSource != null) {\n" \
    "            var from = @Object(nextSource);\n" \
    "            var keys = @ownEnumerablePropertyKeys(from);\n" \
    "            for (var i = 0, keysLength = keys.length; i < keysLength; ++i) {\n" \
    "                var nextKey = keys[i];\n" \
    "                objTarget[nextKey] = from[nextKey];\n" \
    "            }\n" \
    "        }\n" \
    "    }\n" \
    "    return objTarget;\n" \
    "})\n" \
;

const int s_objectConstructorAssignCodeLength = 664;

const ConstructAbility s_objectConstructorAssignCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_operationsPromiseIsPromiseCode =
    "(function (promise)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    return @isObject(promise) && !!promise.@promiseState;\n" \
    "})\n" \
;

const int s_operationsPromiseIsPromiseCodeLength = 102;

const ConstructAbility s_operationsPromiseIsPromiseCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_operationsPromiseNewPromiseReactionCode =
    "(function (capability, handler)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    return {\n" \
    "        @capabilities: capability,\n" \
    "        @handler: handler\n" \
    "    };\n" \
    "})\n" \
;

const int s_operationsPromiseNewPromiseReactionCodeLength = 137;

const ConstructAbility s_operationsPromiseNewPromiseReactionCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_operationsPromiseNewPromiseDeferredCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    return @newPromiseCapability(@Promise);\n" \
    "})\n" \
;

const int s_operationsPromiseNewPromiseDeferredCodeLength = 81;

const ConstructAbility s_operationsPromiseNewPromiseDeferredCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_operationsPromiseNewPromiseCapabilityCode =
    "(function (constructor)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    //\n" \
    "    if (typeof constructor !== \"function\")\n" \
    "        throw new @TypeError(\"promise capability requires a constructor function\");\n" \
    "\n" \
    "    var promiseCapability = {\n" \
    "        @promise: undefined,\n" \
    "        @resolve: undefined,\n" \
    "        @reject: undefined\n" \
    "    };\n" \
    "\n" \
    "    function executor(resolve, reject)\n" \
    "    {\n" \
    "        if (promiseCapability.@resolve !== undefined)\n" \
    "            throw new @TypeError(\"resolve function is already set\");\n" \
    "        if (promiseCapability.@reject !== undefined)\n" \
    "            throw new @TypeError(\"reject function is already set\");\n" \
    "\n" \
    "        promiseCapability.@resolve = resolve;\n" \
    "        promiseCapability.@reject = reject;\n" \
    "    }\n" \
    "\n" \
    "    var promise = new constructor(executor);\n" \
    "\n" \
    "    if (typeof promiseCapability.@resolve !== \"function\")\n" \
    "        throw new @TypeError(\"executor did not take a resolve function\");\n" \
    "\n" \
    "    if (typeof promiseCapability.@reject !== \"function\")\n" \
    "        throw new @TypeError(\"executor did not take a reject function\");\n" \
    "\n" \
    "    promiseCapability.@promise = promise;\n" \
    "\n" \
    "    return promiseCapability;\n" \
    "})\n" \
;

const int s_operationsPromiseNewPromiseCapabilityCodeLength = 1076;

const ConstructAbility s_operationsPromiseNewPromiseCapabilityCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_operationsPromiseTriggerPromiseReactionsCode =
    "(function (reactions, argument)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    for (var index = 0, length = reactions.length; index < length; ++index)\n" \
    "        @enqueueJob(@promiseReactionJob, [reactions[index], argument]);\n" \
    "})\n" \
;

const int s_operationsPromiseTriggerPromiseReactionsCodeLength = 204;

const ConstructAbility s_operationsPromiseTriggerPromiseReactionsCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_operationsPromiseRejectPromiseCode =
    "(function (promise, reason)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var reactions = promise.@promiseRejectReactions;\n" \
    "    promise.@promiseResult = reason;\n" \
    "    promise.@promiseFulfillReactions = undefined;\n" \
    "    promise.@promiseRejectReactions = undefined;\n" \
    "    promise.@promiseState = @promiseRejected;\n" \
    "\n" \
    "    @InspectorInstrumentation.promiseRejected(promise, reason, reactions);\n" \
    "\n" \
    "    @triggerPromiseReactions(reactions, reason);\n" \
    "})\n" \
;

const int s_operationsPromiseRejectPromiseCodeLength = 413;

const ConstructAbility s_operationsPromiseRejectPromiseCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_operationsPromiseFulfillPromiseCode =
    "(function (promise, value)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var reactions = promise.@promiseFulfillReactions;\n" \
    "    promise.@promiseResult = value;\n" \
    "    promise.@promiseFulfillReactions = undefined;\n" \
    "    promise.@promiseRejectReactions = undefined;\n" \
    "    promise.@promiseState = @promiseFulfilled;\n" \
    "\n" \
    "    @InspectorInstrumentation.promiseFulfilled(promise, value, reactions);\n" \
    "\n" \
    "    @triggerPromiseReactions(reactions, value);\n" \
    "})\n" \
;

const int s_operationsPromiseFulfillPromiseCodeLength = 412;

const ConstructAbility s_operationsPromiseFulfillPromiseCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_operationsPromiseCreateResolvingFunctionsCode =
    "(function (promise)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var alreadyResolved = false;\n" \
    "\n" \
    "    var resolve = function (resolution) {\n" \
    "        if (alreadyResolved)\n" \
    "            return undefined;\n" \
    "        alreadyResolved = true;\n" \
    "\n" \
    "        if (resolution === promise)\n" \
    "            return @rejectPromise(promise, new @TypeError(\"Resolve a promise with itself\"));\n" \
    "\n" \
    "        if (!@isObject(resolution))\n" \
    "            return @fulfillPromise(promise, resolution);\n" \
    "\n" \
    "        var then;\n" \
    "        try {\n" \
    "            then = resolution.then;\n" \
    "        } catch (error) {\n" \
    "            return @rejectPromise(promise, error);\n" \
    "        }\n" \
    "\n" \
    "        if (typeof then !== 'function')\n" \
    "            return @fulfillPromise(promise, resolution);\n" \
    "\n" \
    "        @enqueueJob(@promiseResolveThenableJob, [promise, resolution, then]);\n" \
    "\n" \
    "        return undefined;\n" \
    "    };\n" \
    "\n" \
    "    var reject = function (reason) {\n" \
    "        if (alreadyResolved)\n" \
    "            return undefined;\n" \
    "        alreadyResolved = true;\n" \
    "\n" \
    "        return @rejectPromise(promise, reason);\n" \
    "    };\n" \
    "\n" \
    "    return {\n" \
    "        @resolve: resolve,\n" \
    "        @reject: reject\n" \
    "    };\n" \
    "})\n" \
;

const int s_operationsPromiseCreateResolvingFunctionsCodeLength = 1059;

const ConstructAbility s_operationsPromiseCreateResolvingFunctionsCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_operationsPromisePromiseReactionJobCode =
    "(function (reaction, argument)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var promiseCapability = reaction.@capabilities;\n" \
    "\n" \
    "    var result;\n" \
    "    try {\n" \
    "        result = reaction.@handler.@call(undefined, argument);\n" \
    "    } catch (error) {\n" \
    "        return promiseCapability.@reject.@call(undefined, error);\n" \
    "    }\n" \
    "\n" \
    "    return promiseCapability.@resolve.@call(undefined, result);\n" \
    "})\n" \
;

const int s_operationsPromisePromiseReactionJobCodeLength = 356;

const ConstructAbility s_operationsPromisePromiseReactionJobCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_operationsPromisePromiseResolveThenableJobCode =
    "(function (promiseToResolve, thenable, then)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var resolvingFunctions = @createResolvingFunctions(promiseToResolve);\n" \
    "\n" \
    "    try {\n" \
    "        return then.@call(thenable, resolvingFunctions.@resolve, resolvingFunctions.@reject);\n" \
    "    } catch (error) {\n" \
    "        return resolvingFunctions.@reject.@call(undefined, error);\n" \
    "    }\n" \
    "})\n" \
;

const int s_operationsPromisePromiseResolveThenableJobCodeLength = 343;

const ConstructAbility s_operationsPromisePromiseResolveThenableJobCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_operationsPromiseInitializePromiseCode =
    "(function (executor)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    if (typeof executor !== 'function')\n" \
    "        throw new @TypeError(\"Promise constructor takes a function argument\");\n" \
    "\n" \
    "    this.@promiseState = @promisePending;\n" \
    "    this.@promiseFulfillReactions = [];\n" \
    "    this.@promiseRejectReactions = [];\n" \
    "\n" \
    "    var resolvingFunctions = @createResolvingFunctions(this);\n" \
    "    try {\n" \
    "        executor(resolvingFunctions.@resolve, resolvingFunctions.@reject);\n" \
    "    } catch (error) {\n" \
    "        return resolvingFunctions.@reject.@call(undefined, error);\n" \
    "    }\n" \
    "\n" \
    "    return this;\n" \
    "})\n" \
;

const int s_operationsPromiseInitializePromiseCodeLength = 547;

const ConstructAbility s_operationsPromiseInitializePromiseCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_promisePrototypeCatchCode =
    "(function (onRejected)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    return this.then(undefined, onRejected);\n" \
    "})\n" \
;

const int s_promisePrototypeCatchCodeLength = 92;

const ConstructAbility s_promisePrototypeCatchCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_promisePrototypeThenCode =
    "(function (onFulfilled, onRejected)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    if (!@isPromise(this))\n" \
    "        throw new @TypeError(\"|this| is not a object\");\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    var constructor = this.constructor;\n" \
    "\n" \
    "    var resultCapability = @newPromiseCapability(constructor);\n" \
    "\n" \
    "    if (typeof onFulfilled !== \"function\")\n" \
    "        onFulfilled = function (argument) { return argument; };\n" \
    "\n" \
    "    if (typeof onRejected !== \"function\")\n" \
    "        onRejected = function (argument) { throw argument; };\n" \
    "\n" \
    "    var fulfillReaction = @newPromiseReaction(resultCapability, onFulfilled);\n" \
    "    var rejectReaction = @newPromiseReaction(resultCapability, onRejected);\n" \
    "\n" \
    "    var state = this.@promiseState;\n" \
    "\n" \
    "    if (state === @promisePending) {\n" \
    "        @putByValDirect(this.@promiseFulfillReactions, this.@promiseFulfillReactions.length, fulfillReaction)\n" \
    "        @putByValDirect(this.@promiseRejectReactions, this.@promiseRejectReactions.length, rejectReaction)\n" \
    "    } else if (state === @promiseFulfilled)\n" \
    "        @enqueueJob(@promiseReactionJob, [fulfillReaction, this.@promiseResult]);\n" \
    "    else if (state === @promiseRejected)\n" \
    "        @enqueueJob(@promiseReactionJob, [rejectReaction, this.@promiseResult]);\n" \
    "\n" \
    "    return resultCapability.@promise;\n" \
    "})\n" \
;

const int s_promisePrototypeThenCodeLength = 1209;

const ConstructAbility s_promisePrototypeThenCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_promiseConstructorAllCode =
    "(function (iterable)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    if (!@isObject(this))\n" \
    "        throw new TypeError(\"|this| is not a object\");\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    var constructor = this;\n" \
    "\n" \
    "    var promiseCapability = @newPromiseCapability(constructor);\n" \
    "\n" \
    "    var values = [];\n" \
    "    var index = 0;\n" \
    "    var remainingElementsCount = 1;\n" \
    "\n" \
    "    function newResolveElement(index)\n" \
    "    {\n" \
    "        var alreadyCalled = false;\n" \
    "        return function (argument)\n" \
    "        {\n" \
    "            if (alreadyCalled)\n" \
    "                return undefined;\n" \
    "            alreadyCalled = true;\n" \
    "\n" \
    "            @putByValDirect(values, index, argument);\n" \
    "\n" \
    "            --remainingElementsCount;\n" \
    "            if (remainingElementsCount === 0)\n" \
    "                return promiseCapability.@resolve.@call(undefined, values);\n" \
    "\n" \
    "            return undefined;\n" \
    "        }\n" \
    "    }\n" \
    "\n" \
    "    try {\n" \
    "        for (var value of iterable) {\n" \
    "            @putByValDirect(values, index, undefined);\n" \
    "            var nextPromise = constructor.resolve(value);\n" \
    "            var resolveElement = newResolveElement(index);\n" \
    "            ++remainingElementsCount;\n" \
    "            nextPromise.then(resolveElement, promiseCapability.@reject);\n" \
    "            ++index;\n" \
    "        }\n" \
    "\n" \
    "        --remainingElementsCount;\n" \
    "        if (remainingElementsCount === 0)\n" \
    "            promiseCapability.@resolve.@call(undefined, values);\n" \
    "    } catch (error) {\n" \
    "        promiseCapability.@reject.@call(undefined, error);\n" \
    "    }\n" \
    "\n" \
    "    return promiseCapability.@promise;\n" \
    "})\n" \
;

const int s_promiseConstructorAllCodeLength = 1430;

const ConstructAbility s_promiseConstructorAllCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_promiseConstructorRaceCode =
    "(function (iterable)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    if (!@isObject(this))\n" \
    "        throw new TypeError(\"|this| is not a object\");\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    var constructor = this;\n" \
    "\n" \
    "    var promiseCapability = @newPromiseCapability(constructor);\n" \
    "\n" \
    "    try {\n" \
    "        for (var value of iterable) {\n" \
    "            var nextPromise = constructor.resolve(value);\n" \
    "            nextPromise.then(promiseCapability.@resolve, promiseCapability.@reject);\n" \
    "        }\n" \
    "    } catch (error) {\n" \
    "        promiseCapability.@reject.@call(undefined, error);\n" \
    "    }\n" \
    "\n" \
    "    return promiseCapability.@promise;\n" \
    "})\n" \
;

const int s_promiseConstructorRaceCodeLength = 563;

const ConstructAbility s_promiseConstructorRaceCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_promiseConstructorRejectCode =
    "(function (reason)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    if (!@isObject(this))\n" \
    "        throw new TypeError(\"|this| is not a object\");\n" \
    "\n" \
    "    var promiseCapability = @newPromiseCapability(this);\n" \
    "\n" \
    "    promiseCapability.@reject.@call(undefined, reason);\n" \
    "\n" \
    "    return promiseCapability.@promise;\n" \
    "})\n" \
;

const int s_promiseConstructorRejectCodeLength = 279;

const ConstructAbility s_promiseConstructorRejectCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_promiseConstructorResolveCode =
    "(function (value)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    if (!@isObject(this))\n" \
    "        throw new TypeError(\"|this| is not a object\");\n" \
    "\n" \
    "    if (@isPromise(value)) {\n" \
    "        var valueConstructor = value.constructor;\n" \
    "        if (valueConstructor === this)\n" \
    "            return value;\n" \
    "    }\n" \
    "\n" \
    "    var promiseCapability = @newPromiseCapability(this);\n" \
    "\n" \
    "    promiseCapability.@resolve.@call(undefined, value);\n" \
    "\n" \
    "    return promiseCapability.@promise;\n" \
    "})\n" \
;

const int s_promiseConstructorResolveCodeLength = 429;

const ConstructAbility s_promiseConstructorResolveCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_reflectObjectApplyCode =
    "(function (target, thisArgument, argumentsList)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    if (typeof target !== \"function\")\n" \
    "        throw new @TypeError(\"Reflect.apply requires the first argument be a function\");\n" \
    "\n" \
    "    if (!@isObject(argumentsList))\n" \
    "        throw new @TypeError(\"Reflect.apply requires the third argument be an object\");\n" \
    "\n" \
    "    return target.@apply(thisArgument, argumentsList);\n" \
    "})\n" \
;

const int s_reflectObjectApplyCodeLength = 379;

const ConstructAbility s_reflectObjectApplyCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_reflectObjectDeletePropertyCode =
    "(function (target, propertyKey)\n" \
    "{\n" \
    "    //\n" \
    "    //\n" \
    "\n" \
    "    if (!@isObject(target))\n" \
    "        throw new @TypeError(\"Reflect.deleteProperty requires the first argument be an object\");\n" \
    "\n" \
    "    return delete target[propertyKey];\n" \
    "})\n" \
;

const int s_reflectObjectDeletePropertyCodeLength = 217;

const ConstructAbility s_reflectObjectDeletePropertyCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_reflectObjectHasCode =
    "(function (target, propertyKey)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    if (!@isObject(target))\n" \
    "        throw new @TypeError(\"Reflect.has requires the first argument be an object\");\n" \
    "\n" \
    "    return propertyKey in target;\n" \
    "})\n" \
;

const int s_reflectObjectHasCodeLength = 205;

const ConstructAbility s_reflectObjectHasCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_stringConstructorRawCode =
    "(function (template) {\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    if (template === null || template === undefined)\n" \
    "        throw new @TypeError(\"String.raw requires template not be null or undefined\");\n" \
    "    var cookedSegments = @Object(template);\n" \
    "\n" \
    "    var rawValue = cookedSegments.raw;\n" \
    "    if (rawValue === null || rawValue === undefined)\n" \
    "        throw new @TypeError(\"String.raw requires template.raw not be null or undefined\");\n" \
    "    var rawSegments = @Object(rawValue);\n" \
    "\n" \
    "    var numberOfSubstitutions = arguments.length - 1;\n" \
    "\n" \
    "    var segmentCount = @toLength(rawSegments.length);\n" \
    "\n" \
    "    if (segmentCount <= 0)\n" \
    "        return '';\n" \
    "\n" \
    "    var stringElements = '';\n" \
    "    for (var i = 0; ; ++i) {\n" \
    "        var segment = @toString(rawSegments[i]);\n" \
    "        stringElements += segment;\n" \
    "\n" \
    "        if ((i + 1) === segmentCount)\n" \
    "            return stringElements;\n" \
    "\n" \
    "        if (i < numberOfSubstitutions) {\n" \
    "            var substitutionIndexInArguments = i + 1;\n" \
    "            var next = @toString(arguments[substitutionIndexInArguments]);\n" \
    "            stringElements += next;\n" \
    "        }\n" \
    "    }\n" \
    "})\n" \
;

const int s_stringConstructorRawCodeLength = 1051;

const ConstructAbility s_stringConstructorRawCodeConstructAbility = ConstructAbility::CannotConstruct;

const char* s_stringIteratorPrototypeNextCode =
    "(function () {\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"%StringIteratorPrototype%.next requires that |this| not be null or undefined\");\n" \
    "\n" \
    "    var position = this.@stringIteratorNextIndex;\n" \
    "    if (position === undefined)\n" \
    "        throw new @TypeError(\"%StringIteratorPrototype%.next requires that |this| be a String Iterator instance\");\n" \
    "\n" \
    "    var done = true;\n" \
    "    var value = undefined;\n" \
    "\n" \
    "    var string = this.@iteratedString;\n" \
    "    if (string !== undefined) {\n" \
    "        var length = string.length >>> 0;\n" \
    "        if (position >= length) {\n" \
    "            this.@iteratedString = undefined;\n" \
    "        } else {\n" \
    "            done = false;\n" \
    "\n" \
    "            var first = string.@charCodeAt(position);\n" \
    "            if (first < 0xD800 || first > 0xDBFF || position + 1 === length)\n" \
    "                value = string[position];\n" \
    "            else {\n" \
    "                var second = string.@charCodeAt(position + 1);\n" \
    "                if (second < 0xDC00 || second > 0xDFFF)\n" \
    "                    value = string[position];\n" \
    "                else\n" \
    "                    value = string[position] + string[position + 1];\n" \
    "            }\n" \
    "\n" \
    "            this.@stringIteratorNextIndex = position + value.length;\n" \
    "        }\n" \
    "    }\n" \
    "\n" \
    "    return {done, value};\n" \
    "})\n" \
;

const int s_stringIteratorPrototypeNextCodeLength = 1228;

const ConstructAbility s_stringIteratorPrototypeNextCodeConstructAbility = ConstructAbility::CannotConstruct;


#define JSC_DEFINE_BUILTIN_GENERATOR(codeName, functionName, argumentCount) \
FunctionExecutable* codeName##Generator(VM& vm) \
{ \
    return vm.builtinExecutables()->codeName##Executable()->link(vm, vm.builtinExecutables()->codeName##Source()); \
}

JSC_FOREACH_BUILTIN(JSC_DEFINE_BUILTIN_GENERATOR)
#undef JSC_DEFINE_BUILTIN_GENERATOR
}

