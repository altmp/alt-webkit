/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"
#include "JSCanvasRenderingContext2D.h"

#include "CanvasGradient.h"
#include "CanvasPattern.h"
#include "CanvasRenderingContext2D.h"
#include "ExceptionCode.h"
#include "ImageData.h"
#include "JSCanvasGradient.h"
#include "JSCanvasPattern.h"
#include "JSDOMBinding.h"
#include "JSDOMPath.h"
#include "JSElement.h"
#include "JSHTMLCanvasElement.h"
#include "JSHTMLImageElement.h"
#include "JSHTMLVideoElement.h"
#include "JSImageData.h"
#include "JSTextMetrics.h"
#include "TextMetrics.h"
#include "URL.h"
#include <runtime/Error.h>
#include <runtime/JSArray.h>
#include <runtime/JSString.h>
#include <wtf/GetPtr.h>

using namespace JSC;

namespace WebCore {

// Functions

JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSave(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionRestore(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionScale(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionRotate(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionTranslate(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionTransform(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetTransform(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCreateLinearGradient(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCreateRadialGradient(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetLineDash(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionGetLineDash(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionClearRect(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionFillRect(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionBeginPath(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionClosePath(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionMoveTo(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionLineTo(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionQuadraticCurveTo(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionBezierCurveTo(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionArcTo(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionRect(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionArc(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionEllipse(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionFill(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionStroke(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionClip(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionIsPointInPath(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionIsPointInStroke(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionMeasureText(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetAlpha(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetCompositeOperation(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetLineWidth(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetLineCap(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetLineJoin(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetMiterLimit(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionClearShadow(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionFillText(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionStrokeText(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetFillColor(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionStrokeRect(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawImage(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawImageFromRect(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetShadow(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionPutImageData(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionWebkitPutImageDataHD(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCreatePattern(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCreateImageData(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionGetImageData(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionWebkitGetImageDataHD(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawFocusIfNeeded(JSC::ExecState*);

// Attributes

JSC::EncodedJSValue jsCanvasRenderingContext2DGlobalAlpha(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DGlobalAlpha(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DGlobalCompositeOperation(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DGlobalCompositeOperation(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DLineWidth(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DLineWidth(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DLineCap(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DLineCap(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DLineJoin(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DLineJoin(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DMiterLimit(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DMiterLimit(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DShadowOffsetX(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DShadowOffsetX(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DShadowOffsetY(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DShadowOffsetY(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DShadowBlur(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DShadowBlur(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DShadowColor(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DShadowColor(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DLineDashOffset(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DLineDashOffset(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DWebkitLineDash(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DWebkitLineDash(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DWebkitLineDashOffset(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DWebkitLineDashOffset(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DFont(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DFont(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DTextAlign(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DTextAlign(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DTextBaseline(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DTextBaseline(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DDirection(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DDirection(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DStrokeStyle(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DStrokeStyle(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DFillStyle(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DFillStyle(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DWebkitBackingStorePixelRatio(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsCanvasRenderingContext2DImageSmoothingEnabled(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DImageSmoothingEnabled(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DWebkitImageSmoothingEnabled(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);
void setJSCanvasRenderingContext2DWebkitImageSmoothingEnabled(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DConstructor(JSC::ExecState*, JSC::JSObject*, JSC::EncodedJSValue, JSC::PropertyName);

class JSCanvasRenderingContext2DPrototype : public JSC::JSNonFinalObject {
public:
    typedef JSC::JSNonFinalObject Base;
    static JSCanvasRenderingContext2DPrototype* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSCanvasRenderingContext2DPrototype* ptr = new (NotNull, JSC::allocateCell<JSCanvasRenderingContext2DPrototype>(vm.heap)) JSCanvasRenderingContext2DPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm);
        return ptr;
    }

    DECLARE_INFO;
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSCanvasRenderingContext2DPrototype(JSC::VM& vm, JSC::JSGlobalObject*, JSC::Structure* structure)
        : JSC::JSNonFinalObject(vm, structure)
    {
    }

    void finishCreation(JSC::VM&);
};

class JSCanvasRenderingContext2DConstructor : public DOMConstructorObject {
private:
    JSCanvasRenderingContext2DConstructor(JSC::Structure*, JSDOMGlobalObject*);
    void finishCreation(JSC::VM&, JSDOMGlobalObject*);

public:
    typedef DOMConstructorObject Base;
    static JSCanvasRenderingContext2DConstructor* create(JSC::VM& vm, JSC::Structure* structure, JSDOMGlobalObject* globalObject)
    {
        JSCanvasRenderingContext2DConstructor* ptr = new (NotNull, JSC::allocateCell<JSCanvasRenderingContext2DConstructor>(vm.heap)) JSCanvasRenderingContext2DConstructor(structure, globalObject);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }
};

/* Hash table */

static const struct CompactHashIndex JSCanvasRenderingContext2DTableIndex[9] = {
    { -1, -1 },
    { 0, -1 },
    { 1, 8 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { 2, -1 },
};


static const HashTableValue JSCanvasRenderingContext2DTableValues[] =
{
    { "webkitLineDash", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DWebkitLineDash), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DWebkitLineDash) },
    { "strokeStyle", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DStrokeStyle), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DStrokeStyle) },
    { "fillStyle", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DFillStyle), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DFillStyle) },
};

static const HashTable JSCanvasRenderingContext2DTable = { 3, 7, true, JSCanvasRenderingContext2DTableValues, 0, JSCanvasRenderingContext2DTableIndex };
const ClassInfo JSCanvasRenderingContext2DConstructor::s_info = { "CanvasRenderingContext2DConstructor", &Base::s_info, 0, CREATE_METHOD_TABLE(JSCanvasRenderingContext2DConstructor) };

JSCanvasRenderingContext2DConstructor::JSCanvasRenderingContext2DConstructor(Structure* structure, JSDOMGlobalObject* globalObject)
    : DOMConstructorObject(structure, globalObject)
{
}

void JSCanvasRenderingContext2DConstructor::finishCreation(VM& vm, JSDOMGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
    putDirect(vm, vm.propertyNames->prototype, JSCanvasRenderingContext2D::getPrototype(vm, globalObject), DontDelete | ReadOnly | DontEnum);
    putDirect(vm, vm.propertyNames->name, jsNontrivialString(&vm, String(ASCIILiteral("CanvasRenderingContext2D"))), ReadOnly | DontEnum);
    putDirect(vm, vm.propertyNames->length, jsNumber(0), ReadOnly | DontEnum);
}

/* Hash table for prototype */

static const HashTableValue JSCanvasRenderingContext2DPrototypeTableValues[] =
{
    { "constructor", DontEnum | ReadOnly, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DConstructor), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) },
    { "globalAlpha", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DGlobalAlpha), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DGlobalAlpha) },
    { "globalCompositeOperation", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DGlobalCompositeOperation), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DGlobalCompositeOperation) },
    { "lineWidth", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DLineWidth), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DLineWidth) },
    { "lineCap", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DLineCap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DLineCap) },
    { "lineJoin", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DLineJoin), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DLineJoin) },
    { "miterLimit", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DMiterLimit), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DMiterLimit) },
    { "shadowOffsetX", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DShadowOffsetX), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DShadowOffsetX) },
    { "shadowOffsetY", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DShadowOffsetY), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DShadowOffsetY) },
    { "shadowBlur", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DShadowBlur), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DShadowBlur) },
    { "shadowColor", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DShadowColor), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DShadowColor) },
    { "lineDashOffset", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DLineDashOffset), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DLineDashOffset) },
    { "webkitLineDashOffset", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DWebkitLineDashOffset), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DWebkitLineDashOffset) },
    { "font", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DFont), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DFont) },
    { "textAlign", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DTextAlign), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DTextAlign) },
    { "textBaseline", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DTextBaseline), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DTextBaseline) },
    { "direction", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DDirection), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DDirection) },
    { "webkitBackingStorePixelRatio", DontDelete | ReadOnly | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DWebkitBackingStorePixelRatio), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) },
    { "imageSmoothingEnabled", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DImageSmoothingEnabled), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DImageSmoothingEnabled) },
    { "webkitImageSmoothingEnabled", DontDelete | CustomAccessor, NoIntrinsic, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DWebkitImageSmoothingEnabled), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DWebkitImageSmoothingEnabled) },
    { "save", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSave), (intptr_t) (0) },
    { "restore", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionRestore), (intptr_t) (0) },
    { "scale", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionScale), (intptr_t) (2) },
    { "rotate", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionRotate), (intptr_t) (1) },
    { "translate", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionTranslate), (intptr_t) (2) },
    { "transform", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionTransform), (intptr_t) (6) },
    { "setTransform", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetTransform), (intptr_t) (6) },
    { "createLinearGradient", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionCreateLinearGradient), (intptr_t) (4) },
    { "createRadialGradient", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionCreateRadialGradient), (intptr_t) (6) },
    { "setLineDash", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetLineDash), (intptr_t) (1) },
    { "getLineDash", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionGetLineDash), (intptr_t) (0) },
    { "clearRect", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionClearRect), (intptr_t) (4) },
    { "fillRect", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionFillRect), (intptr_t) (4) },
    { "beginPath", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionBeginPath), (intptr_t) (0) },
    { "closePath", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionClosePath), (intptr_t) (0) },
    { "moveTo", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionMoveTo), (intptr_t) (2) },
    { "lineTo", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionLineTo), (intptr_t) (2) },
    { "quadraticCurveTo", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionQuadraticCurveTo), (intptr_t) (4) },
    { "bezierCurveTo", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionBezierCurveTo), (intptr_t) (6) },
    { "arcTo", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionArcTo), (intptr_t) (5) },
    { "rect", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionRect), (intptr_t) (4) },
    { "arc", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionArc), (intptr_t) (5) },
    { "ellipse", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionEllipse), (intptr_t) (7) },
    { "fill", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionFill), (intptr_t) (1) },
    { "stroke", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionStroke), (intptr_t) (1) },
    { "clip", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionClip), (intptr_t) (1) },
    { "isPointInPath", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionIsPointInPath), (intptr_t) (3) },
    { "isPointInStroke", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionIsPointInStroke), (intptr_t) (3) },
    { "measureText", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionMeasureText), (intptr_t) (1) },
    { "setAlpha", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetAlpha), (intptr_t) (0) },
    { "setCompositeOperation", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetCompositeOperation), (intptr_t) (0) },
    { "setLineWidth", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetLineWidth), (intptr_t) (0) },
    { "setLineCap", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetLineCap), (intptr_t) (0) },
    { "setLineJoin", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetLineJoin), (intptr_t) (0) },
    { "setMiterLimit", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetMiterLimit), (intptr_t) (0) },
    { "clearShadow", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionClearShadow), (intptr_t) (0) },
    { "fillText", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionFillText), (intptr_t) (3) },
    { "strokeText", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionStrokeText), (intptr_t) (3) },
    { "setStrokeColor", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor), (intptr_t) (1) },
    { "setFillColor", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetFillColor), (intptr_t) (1) },
    { "strokeRect", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionStrokeRect), (intptr_t) (4) },
    { "drawImage", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionDrawImage), (intptr_t) (3) },
    { "drawImageFromRect", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionDrawImageFromRect), (intptr_t) (1) },
    { "setShadow", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetShadow), (intptr_t) (3) },
    { "putImageData", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionPutImageData), (intptr_t) (3) },
    { "webkitPutImageDataHD", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionWebkitPutImageDataHD), (intptr_t) (3) },
    { "createPattern", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionCreatePattern), (intptr_t) (2) },
    { "createImageData", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionCreateImageData), (intptr_t) (1) },
    { "getImageData", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionGetImageData), (intptr_t) (4) },
    { "webkitGetImageDataHD", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionWebkitGetImageDataHD), (intptr_t) (4) },
    { "drawFocusIfNeeded", JSC::Function, NoIntrinsic, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionDrawFocusIfNeeded), (intptr_t) (1) },
};

const ClassInfo JSCanvasRenderingContext2DPrototype::s_info = { "CanvasRenderingContext2DPrototype", &Base::s_info, 0, CREATE_METHOD_TABLE(JSCanvasRenderingContext2DPrototype) };

void JSCanvasRenderingContext2DPrototype::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSCanvasRenderingContext2DPrototypeTableValues, *this);
}

const ClassInfo JSCanvasRenderingContext2D::s_info = { "CanvasRenderingContext2D", &Base::s_info, &JSCanvasRenderingContext2DTable, CREATE_METHOD_TABLE(JSCanvasRenderingContext2D) };

JSCanvasRenderingContext2D::JSCanvasRenderingContext2D(Structure* structure, JSDOMGlobalObject* globalObject, Ref<CanvasRenderingContext2D>&& impl)
    : JSCanvasRenderingContext(structure, globalObject, WTF::move(impl))
{
}

JSObject* JSCanvasRenderingContext2D::createPrototype(VM& vm, JSGlobalObject* globalObject)
{
    return JSCanvasRenderingContext2DPrototype::create(vm, globalObject, JSCanvasRenderingContext2DPrototype::createStructure(vm, globalObject, JSCanvasRenderingContext::getPrototype(vm, globalObject)));
}

JSObject* JSCanvasRenderingContext2D::getPrototype(VM& vm, JSGlobalObject* globalObject)
{
    return getDOMPrototype<JSCanvasRenderingContext2D>(vm, globalObject);
}

bool JSCanvasRenderingContext2D::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot& slot)
{
    auto* thisObject = jsCast<JSCanvasRenderingContext2D*>(object);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    return getStaticValueSlot<JSCanvasRenderingContext2D, Base>(exec, JSCanvasRenderingContext2DTable, thisObject, propertyName, slot);
}

EncodedJSValue jsCanvasRenderingContext2DGlobalAlpha(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(slotBase))
            return reportDeprecatedGetterError(*exec, "CanvasRenderingContext2D", "globalAlpha");
        return throwGetterTypeError(*exec, "CanvasRenderingContext2D", "globalAlpha");
    }
    auto& impl = castedThis->impl();
    JSValue result = jsNumber(impl.globalAlpha());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DGlobalCompositeOperation(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(slotBase))
            return reportDeprecatedGetterError(*exec, "CanvasRenderingContext2D", "globalCompositeOperation");
        return throwGetterTypeError(*exec, "CanvasRenderingContext2D", "globalCompositeOperation");
    }
    auto& impl = castedThis->impl();
    JSValue result = jsStringWithCache(exec, impl.globalCompositeOperation());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DLineWidth(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(slotBase))
            return reportDeprecatedGetterError(*exec, "CanvasRenderingContext2D", "lineWidth");
        return throwGetterTypeError(*exec, "CanvasRenderingContext2D", "lineWidth");
    }
    auto& impl = castedThis->impl();
    JSValue result = jsNumber(impl.lineWidth());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DLineCap(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(slotBase))
            return reportDeprecatedGetterError(*exec, "CanvasRenderingContext2D", "lineCap");
        return throwGetterTypeError(*exec, "CanvasRenderingContext2D", "lineCap");
    }
    auto& impl = castedThis->impl();
    JSValue result = jsStringWithCache(exec, impl.lineCap());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DLineJoin(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(slotBase))
            return reportDeprecatedGetterError(*exec, "CanvasRenderingContext2D", "lineJoin");
        return throwGetterTypeError(*exec, "CanvasRenderingContext2D", "lineJoin");
    }
    auto& impl = castedThis->impl();
    JSValue result = jsStringWithCache(exec, impl.lineJoin());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DMiterLimit(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(slotBase))
            return reportDeprecatedGetterError(*exec, "CanvasRenderingContext2D", "miterLimit");
        return throwGetterTypeError(*exec, "CanvasRenderingContext2D", "miterLimit");
    }
    auto& impl = castedThis->impl();
    JSValue result = jsNumber(impl.miterLimit());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DShadowOffsetX(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(slotBase))
            return reportDeprecatedGetterError(*exec, "CanvasRenderingContext2D", "shadowOffsetX");
        return throwGetterTypeError(*exec, "CanvasRenderingContext2D", "shadowOffsetX");
    }
    auto& impl = castedThis->impl();
    JSValue result = jsNumber(impl.shadowOffsetX());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DShadowOffsetY(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(slotBase))
            return reportDeprecatedGetterError(*exec, "CanvasRenderingContext2D", "shadowOffsetY");
        return throwGetterTypeError(*exec, "CanvasRenderingContext2D", "shadowOffsetY");
    }
    auto& impl = castedThis->impl();
    JSValue result = jsNumber(impl.shadowOffsetY());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DShadowBlur(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(slotBase))
            return reportDeprecatedGetterError(*exec, "CanvasRenderingContext2D", "shadowBlur");
        return throwGetterTypeError(*exec, "CanvasRenderingContext2D", "shadowBlur");
    }
    auto& impl = castedThis->impl();
    JSValue result = jsNumber(impl.shadowBlur());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DShadowColor(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(slotBase))
            return reportDeprecatedGetterError(*exec, "CanvasRenderingContext2D", "shadowColor");
        return throwGetterTypeError(*exec, "CanvasRenderingContext2D", "shadowColor");
    }
    auto& impl = castedThis->impl();
    JSValue result = jsStringWithCache(exec, impl.shadowColor());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DLineDashOffset(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(slotBase))
            return reportDeprecatedGetterError(*exec, "CanvasRenderingContext2D", "lineDashOffset");
        return throwGetterTypeError(*exec, "CanvasRenderingContext2D", "lineDashOffset");
    }
    auto& impl = castedThis->impl();
    JSValue result = jsNumber(impl.lineDashOffset());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DWebkitLineDash(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    auto* castedThis = jsCast<JSCanvasRenderingContext2D*>(slotBase);
    return JSValue::encode(castedThis->webkitLineDash(exec));
}


EncodedJSValue jsCanvasRenderingContext2DWebkitLineDashOffset(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(slotBase))
            return reportDeprecatedGetterError(*exec, "CanvasRenderingContext2D", "webkitLineDashOffset");
        return throwGetterTypeError(*exec, "CanvasRenderingContext2D", "webkitLineDashOffset");
    }
    auto& impl = castedThis->impl();
    JSValue result = jsNumber(impl.webkitLineDashOffset());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DFont(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(slotBase))
            return reportDeprecatedGetterError(*exec, "CanvasRenderingContext2D", "font");
        return throwGetterTypeError(*exec, "CanvasRenderingContext2D", "font");
    }
    auto& impl = castedThis->impl();
    JSValue result = jsStringWithCache(exec, impl.font());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DTextAlign(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(slotBase))
            return reportDeprecatedGetterError(*exec, "CanvasRenderingContext2D", "textAlign");
        return throwGetterTypeError(*exec, "CanvasRenderingContext2D", "textAlign");
    }
    auto& impl = castedThis->impl();
    JSValue result = jsStringWithCache(exec, impl.textAlign());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DTextBaseline(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(slotBase))
            return reportDeprecatedGetterError(*exec, "CanvasRenderingContext2D", "textBaseline");
        return throwGetterTypeError(*exec, "CanvasRenderingContext2D", "textBaseline");
    }
    auto& impl = castedThis->impl();
    JSValue result = jsStringWithCache(exec, impl.textBaseline());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DDirection(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(slotBase))
            return reportDeprecatedGetterError(*exec, "CanvasRenderingContext2D", "direction");
        return throwGetterTypeError(*exec, "CanvasRenderingContext2D", "direction");
    }
    auto& impl = castedThis->impl();
    JSValue result = jsStringWithCache(exec, impl.direction());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DStrokeStyle(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    auto* castedThis = jsCast<JSCanvasRenderingContext2D*>(slotBase);
    return JSValue::encode(castedThis->strokeStyle(exec));
}


EncodedJSValue jsCanvasRenderingContext2DFillStyle(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    auto* castedThis = jsCast<JSCanvasRenderingContext2D*>(slotBase);
    return JSValue::encode(castedThis->fillStyle(exec));
}


EncodedJSValue jsCanvasRenderingContext2DWebkitBackingStorePixelRatio(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(slotBase))
            return reportDeprecatedGetterError(*exec, "CanvasRenderingContext2D", "webkitBackingStorePixelRatio");
        return throwGetterTypeError(*exec, "CanvasRenderingContext2D", "webkitBackingStorePixelRatio");
    }
    auto& impl = castedThis->impl();
    JSValue result = jsNumber(impl.webkitBackingStorePixelRatio());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DImageSmoothingEnabled(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(slotBase))
            return reportDeprecatedGetterError(*exec, "CanvasRenderingContext2D", "imageSmoothingEnabled");
        return throwGetterTypeError(*exec, "CanvasRenderingContext2D", "imageSmoothingEnabled");
    }
    auto& impl = castedThis->impl();
    JSValue result = jsBoolean(impl.imageSmoothingEnabled());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DWebkitImageSmoothingEnabled(ExecState* exec, JSObject* slotBase, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(exec);
    UNUSED_PARAM(slotBase);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(slotBase))
            return reportDeprecatedGetterError(*exec, "CanvasRenderingContext2D", "webkitImageSmoothingEnabled");
        return throwGetterTypeError(*exec, "CanvasRenderingContext2D", "webkitImageSmoothingEnabled");
    }
    auto& impl = castedThis->impl();
    JSValue result = jsBoolean(impl.imageSmoothingEnabled());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DConstructor(ExecState* exec, JSObject* baseValue, EncodedJSValue, PropertyName)
{
    JSCanvasRenderingContext2DPrototype* domObject = jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(baseValue);
    if (!domObject)
        return throwVMTypeError(exec);
    return JSValue::encode(JSCanvasRenderingContext2D::getConstructor(exec->vm(), domObject->globalObject()));
}

void setJSCanvasRenderingContext2DGlobalAlpha(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(JSValue::decode(thisValue)))
            reportDeprecatedSetterError(*exec, "CanvasRenderingContext2D", "globalAlpha");
        else
            throwSetterTypeError(*exec, "CanvasRenderingContext2D", "globalAlpha");
        return;
    }
    auto& impl = castedThis->impl();
    float nativeValue = value.toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return;
    impl.setGlobalAlpha(nativeValue);
}


void setJSCanvasRenderingContext2DGlobalCompositeOperation(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(JSValue::decode(thisValue)))
            reportDeprecatedSetterError(*exec, "CanvasRenderingContext2D", "globalCompositeOperation");
        else
            throwSetterTypeError(*exec, "CanvasRenderingContext2D", "globalCompositeOperation");
        return;
    }
    auto& impl = castedThis->impl();
    String nativeValue = valueToStringWithNullCheck(exec, value);
    if (UNLIKELY(exec->hadException()))
        return;
    impl.setGlobalCompositeOperation(nativeValue);
}


void setJSCanvasRenderingContext2DLineWidth(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(JSValue::decode(thisValue)))
            reportDeprecatedSetterError(*exec, "CanvasRenderingContext2D", "lineWidth");
        else
            throwSetterTypeError(*exec, "CanvasRenderingContext2D", "lineWidth");
        return;
    }
    auto& impl = castedThis->impl();
    float nativeValue = value.toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return;
    impl.setLineWidth(nativeValue);
}


void setJSCanvasRenderingContext2DLineCap(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(JSValue::decode(thisValue)))
            reportDeprecatedSetterError(*exec, "CanvasRenderingContext2D", "lineCap");
        else
            throwSetterTypeError(*exec, "CanvasRenderingContext2D", "lineCap");
        return;
    }
    auto& impl = castedThis->impl();
    String nativeValue = valueToStringWithNullCheck(exec, value);
    if (UNLIKELY(exec->hadException()))
        return;
    impl.setLineCap(nativeValue);
}


void setJSCanvasRenderingContext2DLineJoin(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(JSValue::decode(thisValue)))
            reportDeprecatedSetterError(*exec, "CanvasRenderingContext2D", "lineJoin");
        else
            throwSetterTypeError(*exec, "CanvasRenderingContext2D", "lineJoin");
        return;
    }
    auto& impl = castedThis->impl();
    String nativeValue = valueToStringWithNullCheck(exec, value);
    if (UNLIKELY(exec->hadException()))
        return;
    impl.setLineJoin(nativeValue);
}


void setJSCanvasRenderingContext2DMiterLimit(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(JSValue::decode(thisValue)))
            reportDeprecatedSetterError(*exec, "CanvasRenderingContext2D", "miterLimit");
        else
            throwSetterTypeError(*exec, "CanvasRenderingContext2D", "miterLimit");
        return;
    }
    auto& impl = castedThis->impl();
    float nativeValue = value.toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return;
    impl.setMiterLimit(nativeValue);
}


void setJSCanvasRenderingContext2DShadowOffsetX(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(JSValue::decode(thisValue)))
            reportDeprecatedSetterError(*exec, "CanvasRenderingContext2D", "shadowOffsetX");
        else
            throwSetterTypeError(*exec, "CanvasRenderingContext2D", "shadowOffsetX");
        return;
    }
    auto& impl = castedThis->impl();
    float nativeValue = value.toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return;
    impl.setShadowOffsetX(nativeValue);
}


void setJSCanvasRenderingContext2DShadowOffsetY(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(JSValue::decode(thisValue)))
            reportDeprecatedSetterError(*exec, "CanvasRenderingContext2D", "shadowOffsetY");
        else
            throwSetterTypeError(*exec, "CanvasRenderingContext2D", "shadowOffsetY");
        return;
    }
    auto& impl = castedThis->impl();
    float nativeValue = value.toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return;
    impl.setShadowOffsetY(nativeValue);
}


void setJSCanvasRenderingContext2DShadowBlur(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(JSValue::decode(thisValue)))
            reportDeprecatedSetterError(*exec, "CanvasRenderingContext2D", "shadowBlur");
        else
            throwSetterTypeError(*exec, "CanvasRenderingContext2D", "shadowBlur");
        return;
    }
    auto& impl = castedThis->impl();
    float nativeValue = value.toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return;
    impl.setShadowBlur(nativeValue);
}


void setJSCanvasRenderingContext2DShadowColor(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(JSValue::decode(thisValue)))
            reportDeprecatedSetterError(*exec, "CanvasRenderingContext2D", "shadowColor");
        else
            throwSetterTypeError(*exec, "CanvasRenderingContext2D", "shadowColor");
        return;
    }
    auto& impl = castedThis->impl();
    String nativeValue = valueToStringWithNullCheck(exec, value);
    if (UNLIKELY(exec->hadException()))
        return;
    impl.setShadowColor(nativeValue);
}


void setJSCanvasRenderingContext2DLineDashOffset(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(JSValue::decode(thisValue)))
            reportDeprecatedSetterError(*exec, "CanvasRenderingContext2D", "lineDashOffset");
        else
            throwSetterTypeError(*exec, "CanvasRenderingContext2D", "lineDashOffset");
        return;
    }
    auto& impl = castedThis->impl();
    float nativeValue = value.toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return;
    impl.setLineDashOffset(nativeValue);
}


void setJSCanvasRenderingContext2DWebkitLineDash(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    UNUSED_PARAM(thisValue);
    auto* castedThis = jsCast<JSCanvasRenderingContext2D*>(baseObject);
    UNUSED_PARAM(thisValue);
    UNUSED_PARAM(exec);
    castedThis->setWebkitLineDash(exec, value);
}


void setJSCanvasRenderingContext2DWebkitLineDashOffset(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(JSValue::decode(thisValue)))
            reportDeprecatedSetterError(*exec, "CanvasRenderingContext2D", "webkitLineDashOffset");
        else
            throwSetterTypeError(*exec, "CanvasRenderingContext2D", "webkitLineDashOffset");
        return;
    }
    auto& impl = castedThis->impl();
    float nativeValue = value.toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return;
    impl.setWebkitLineDashOffset(nativeValue);
}


void setJSCanvasRenderingContext2DFont(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(JSValue::decode(thisValue)))
            reportDeprecatedSetterError(*exec, "CanvasRenderingContext2D", "font");
        else
            throwSetterTypeError(*exec, "CanvasRenderingContext2D", "font");
        return;
    }
    auto& impl = castedThis->impl();
    String nativeValue = value.toString(exec)->value(exec);
    if (UNLIKELY(exec->hadException()))
        return;
    impl.setFont(nativeValue);
}


void setJSCanvasRenderingContext2DTextAlign(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(JSValue::decode(thisValue)))
            reportDeprecatedSetterError(*exec, "CanvasRenderingContext2D", "textAlign");
        else
            throwSetterTypeError(*exec, "CanvasRenderingContext2D", "textAlign");
        return;
    }
    auto& impl = castedThis->impl();
    String nativeValue = value.toString(exec)->value(exec);
    if (UNLIKELY(exec->hadException()))
        return;
    impl.setTextAlign(nativeValue);
}


void setJSCanvasRenderingContext2DTextBaseline(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(JSValue::decode(thisValue)))
            reportDeprecatedSetterError(*exec, "CanvasRenderingContext2D", "textBaseline");
        else
            throwSetterTypeError(*exec, "CanvasRenderingContext2D", "textBaseline");
        return;
    }
    auto& impl = castedThis->impl();
    String nativeValue = value.toString(exec)->value(exec);
    if (UNLIKELY(exec->hadException()))
        return;
    impl.setTextBaseline(nativeValue);
}


void setJSCanvasRenderingContext2DDirection(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(JSValue::decode(thisValue)))
            reportDeprecatedSetterError(*exec, "CanvasRenderingContext2D", "direction");
        else
            throwSetterTypeError(*exec, "CanvasRenderingContext2D", "direction");
        return;
    }
    auto& impl = castedThis->impl();
    String nativeValue = value.toString(exec)->value(exec);
    if (UNLIKELY(exec->hadException()))
        return;
    impl.setDirection(nativeValue);
}


void setJSCanvasRenderingContext2DStrokeStyle(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    UNUSED_PARAM(thisValue);
    auto* castedThis = jsCast<JSCanvasRenderingContext2D*>(baseObject);
    UNUSED_PARAM(thisValue);
    UNUSED_PARAM(exec);
    castedThis->setStrokeStyle(exec, value);
}


void setJSCanvasRenderingContext2DFillStyle(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    UNUSED_PARAM(thisValue);
    auto* castedThis = jsCast<JSCanvasRenderingContext2D*>(baseObject);
    UNUSED_PARAM(thisValue);
    UNUSED_PARAM(exec);
    castedThis->setFillStyle(exec, value);
}


void setJSCanvasRenderingContext2DImageSmoothingEnabled(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(JSValue::decode(thisValue)))
            reportDeprecatedSetterError(*exec, "CanvasRenderingContext2D", "imageSmoothingEnabled");
        else
            throwSetterTypeError(*exec, "CanvasRenderingContext2D", "imageSmoothingEnabled");
        return;
    }
    auto& impl = castedThis->impl();
    bool nativeValue = value.toBoolean(exec);
    if (UNLIKELY(exec->hadException()))
        return;
    impl.setImageSmoothingEnabled(nativeValue);
}


void setJSCanvasRenderingContext2DWebkitImageSmoothingEnabled(ExecState* exec, JSObject* baseObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(baseObject);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        if (jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(JSValue::decode(thisValue)))
            reportDeprecatedSetterError(*exec, "CanvasRenderingContext2D", "webkitImageSmoothingEnabled");
        else
            throwSetterTypeError(*exec, "CanvasRenderingContext2D", "webkitImageSmoothingEnabled");
        return;
    }
    auto& impl = castedThis->impl();
    bool nativeValue = value.toBoolean(exec);
    if (UNLIKELY(exec->hadException()))
        return;
    impl.setImageSmoothingEnabled(nativeValue);
}


JSValue JSCanvasRenderingContext2D::getConstructor(VM& vm, JSGlobalObject* globalObject)
{
    return getDOMConstructor<JSCanvasRenderingContext2DConstructor>(vm, jsCast<JSDOMGlobalObject*>(globalObject));
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSave(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "save");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    impl.save();
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionRestore(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "restore");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    impl.restore();
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionScale(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "scale");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 2))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float sx = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float sy = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.scale(sx, sy);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionRotate(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "rotate");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 1))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float angle = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.rotate(angle);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionTranslate(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "translate");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 2))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float tx = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float ty = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.translate(tx, ty);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionTransform(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "transform");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 6))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float m11 = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float m12 = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float m21 = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float m22 = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float dx = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float dy = exec->argument(5).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.transform(m11, m12, m21, m22, dx, dy);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetTransform(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "setTransform");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 6))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float m11 = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float m12 = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float m21 = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float m22 = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float dx = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float dy = exec->argument(5).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setTransform(m11, m12, m21, m22, dx, dy);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCreateLinearGradient(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "createLinearGradient");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 4))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    float x0 = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(x0)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float y0 = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(y0)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float x1 = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(x1)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float y1 = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(y1)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl.createLinearGradient(x0, y0, x1, y1, ec)));

    setDOMException(exec, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCreateRadialGradient(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "createRadialGradient");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 6))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    float x0 = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(x0)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float y0 = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(y0)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float r0 = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(r0)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float x1 = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(x1)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float y1 = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(y1)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float r1 = exec->argument(5).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(r1)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl.createRadialGradient(x0, y0, r0, x1, y1, r1, ec)));

    setDOMException(exec, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetLineDash(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "setLineDash");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 1))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    Vector<float> dash = toNativeArray<float>(exec, exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setLineDash(dash);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionGetLineDash(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "getLineDash");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    JSValue result = jsArray(exec, castedThis->globalObject(), impl.getLineDash());
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionClearRect(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "clearRect");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 4))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float x = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float width = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float height = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.clearRect(x, y, width, height);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionFillRect(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "fillRect");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 4))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float x = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float width = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float height = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.fillRect(x, y, width, height);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionBeginPath(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "beginPath");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    impl.beginPath();
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionClosePath(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "closePath");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    impl.closePath();
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionMoveTo(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "moveTo");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 2))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float x = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.moveTo(x, y);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionLineTo(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "lineTo");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 2))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float x = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.lineTo(x, y);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionQuadraticCurveTo(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "quadraticCurveTo");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 4))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float cpx = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float cpy = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float x = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.quadraticCurveTo(cpx, cpy, x, y);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionBezierCurveTo(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "bezierCurveTo");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 6))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float cp1x = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float cp1y = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float cp2x = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float cp2y = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float x = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(5).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionArcTo(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "arcTo");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 5))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    float x1 = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y1 = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float x2 = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y2 = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float radius = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.arcTo(x1, y1, x2, y2, radius, ec);
    setDOMException(exec, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionRect(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "rect");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 4))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float x = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float width = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float height = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.rect(x, y, width, height);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionArc(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "arc");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 5))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    float x = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float radius = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float startAngle = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float endAngle = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    bool anticlockwise = exec->argument(5).toBoolean(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.arc(x, y, radius, startAngle, endAngle, anticlockwise, ec);
    setDOMException(exec, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionEllipse(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "ellipse");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 7))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    float x = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float radiusX = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float radiusY = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float rotation = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float startAngle = exec->argument(5).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float endAngle = exec->argument(6).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    bool anticlockwise = exec->argument(7).toBoolean(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise, ec);
    setDOMException(exec, ec);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionFill1(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "fill");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 1))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    DOMPath* path = JSDOMPath::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());

    size_t argsCount = exec->argumentCount();
    if (argsCount <= 1) {
        impl.fill(path);
        return JSValue::encode(jsUndefined());
    }

    // Keep pointer to the JSString in a local so we don't need to ref the String.
    auto* windingString = exec->argument(1).toString(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    auto& winding = windingString->value(exec);
    if (winding != "nonzero" && winding != "evenodd")
        return throwArgumentMustBeEnumError(*exec, 1, "winding", "CanvasRenderingContext2D", "fill", "\"nonzero\", \"evenodd\"");
    impl.fill(path, winding);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionStroke1(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "stroke");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 1))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    DOMPath* path = JSDOMPath::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.stroke(path);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionClip1(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "clip");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 1))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    DOMPath* path = JSDOMPath::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());

    size_t argsCount = exec->argumentCount();
    if (argsCount <= 1) {
        impl.clip(path);
        return JSValue::encode(jsUndefined());
    }

    // Keep pointer to the JSString in a local so we don't need to ref the String.
    auto* windingString = exec->argument(1).toString(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    auto& winding = windingString->value(exec);
    if (winding != "nonzero" && winding != "evenodd")
        return throwArgumentMustBeEnumError(*exec, 1, "winding", "CanvasRenderingContext2D", "clip", "\"nonzero\", \"evenodd\"");
    impl.clip(path, winding);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionFill2(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "fill");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();

    size_t argsCount = exec->argumentCount();
    if (argsCount <= 0) {
        impl.fill();
        return JSValue::encode(jsUndefined());
    }

    // Keep pointer to the JSString in a local so we don't need to ref the String.
    auto* windingString = exec->argument(0).toString(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    auto& winding = windingString->value(exec);
    if (winding != "nonzero" && winding != "evenodd")
        return throwArgumentMustBeEnumError(*exec, 0, "winding", "CanvasRenderingContext2D", "fill", "\"nonzero\", \"evenodd\"");
    impl.fill(winding);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionFill(ExecState* exec)
{
    size_t argsCount = std::min<size_t>(2, exec->argumentCount());
    JSValue arg0(exec->argument(0));
    if ((argsCount == 1 && ((arg0.isObject() && asObject(arg0)->inherits(JSDOMPath::info())))) || (argsCount == 2 && ((arg0.isObject() && asObject(arg0)->inherits(JSDOMPath::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionFill1(exec);
    if (argsCount == 0 || argsCount == 1)
        return jsCanvasRenderingContext2DPrototypeFunctionFill2(exec);
    return throwVMTypeError(exec);
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionStroke2(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "stroke");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    impl.stroke();
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionStroke(ExecState* exec)
{
    size_t argsCount = std::min<size_t>(1, exec->argumentCount());
    JSValue arg0(exec->argument(0));
    if ((argsCount == 1 && ((arg0.isObject() && asObject(arg0)->inherits(JSDOMPath::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionStroke1(exec);
    if (argsCount == 0)
        return jsCanvasRenderingContext2DPrototypeFunctionStroke2(exec);
    return throwVMTypeError(exec);
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionClip2(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "clip");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();

    size_t argsCount = exec->argumentCount();
    if (argsCount <= 0) {
        impl.clip();
        return JSValue::encode(jsUndefined());
    }

    // Keep pointer to the JSString in a local so we don't need to ref the String.
    auto* windingString = exec->argument(0).toString(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    auto& winding = windingString->value(exec);
    if (winding != "nonzero" && winding != "evenodd")
        return throwArgumentMustBeEnumError(*exec, 0, "winding", "CanvasRenderingContext2D", "clip", "\"nonzero\", \"evenodd\"");
    impl.clip(winding);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionClip(ExecState* exec)
{
    size_t argsCount = std::min<size_t>(2, exec->argumentCount());
    JSValue arg0(exec->argument(0));
    if ((argsCount == 1 && ((arg0.isObject() && asObject(arg0)->inherits(JSDOMPath::info())))) || (argsCount == 2 && ((arg0.isObject() && asObject(arg0)->inherits(JSDOMPath::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionClip1(exec);
    if (argsCount == 0 || argsCount == 1)
        return jsCanvasRenderingContext2DPrototypeFunctionClip2(exec);
    return throwVMTypeError(exec);
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionIsPointInPath1(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "isPointInPath");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 3))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    DOMPath* path = JSDOMPath::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float x = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());

    size_t argsCount = exec->argumentCount();
    if (argsCount <= 3) {
        JSValue result = jsBoolean(impl.isPointInPath(path, x, y));
        return JSValue::encode(result);
    }

    // Keep pointer to the JSString in a local so we don't need to ref the String.
    auto* windingString = exec->argument(3).toString(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    auto& winding = windingString->value(exec);
    if (winding != "nonzero" && winding != "evenodd")
        return throwArgumentMustBeEnumError(*exec, 3, "winding", "CanvasRenderingContext2D", "isPointInPath", "\"nonzero\", \"evenodd\"");
    JSValue result = jsBoolean(impl.isPointInPath(path, x, y, winding));
    return JSValue::encode(result);
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionIsPointInStroke1(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "isPointInStroke");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 3))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    DOMPath* path = JSDOMPath::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float x = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = jsBoolean(impl.isPointInStroke(path, x, y));
    return JSValue::encode(result);
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionIsPointInPath2(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "isPointInPath");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 2))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float x = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());

    size_t argsCount = exec->argumentCount();
    if (argsCount <= 2) {
        JSValue result = jsBoolean(impl.isPointInPath(x, y));
        return JSValue::encode(result);
    }

    // Keep pointer to the JSString in a local so we don't need to ref the String.
    auto* windingString = exec->argument(2).toString(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    auto& winding = windingString->value(exec);
    if (winding != "nonzero" && winding != "evenodd")
        return throwArgumentMustBeEnumError(*exec, 2, "winding", "CanvasRenderingContext2D", "isPointInPath", "\"nonzero\", \"evenodd\"");
    JSValue result = jsBoolean(impl.isPointInPath(x, y, winding));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionIsPointInPath(ExecState* exec)
{
    size_t argsCount = std::min<size_t>(4, exec->argumentCount());
    JSValue arg0(exec->argument(0));
    if ((argsCount == 3 && ((arg0.isObject() && asObject(arg0)->inherits(JSDOMPath::info())))) || (argsCount == 4 && ((arg0.isObject() && asObject(arg0)->inherits(JSDOMPath::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionIsPointInPath1(exec);
    if (argsCount == 2 || argsCount == 3)
        return jsCanvasRenderingContext2DPrototypeFunctionIsPointInPath2(exec);
    if (argsCount < 2)
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    return throwVMTypeError(exec);
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionIsPointInStroke2(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "isPointInStroke");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 2))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float x = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = jsBoolean(impl.isPointInStroke(x, y));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionIsPointInStroke(ExecState* exec)
{
    size_t argsCount = std::min<size_t>(3, exec->argumentCount());
    JSValue arg0(exec->argument(0));
    if ((argsCount == 3 && ((arg0.isObject() && asObject(arg0)->inherits(JSDOMPath::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionIsPointInStroke1(exec);
    if (argsCount == 2)
        return jsCanvasRenderingContext2DPrototypeFunctionIsPointInStroke2(exec);
    if (argsCount < 2)
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    return throwVMTypeError(exec);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionMeasureText(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "measureText");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 1))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    String text = exec->argument(0).toString(exec)->value(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl.measureText(text)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetAlpha(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "setAlpha");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    float alpha = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setAlpha(alpha);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetCompositeOperation(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "setCompositeOperation");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    String compositeOperation = exec->argument(0).toString(exec)->value(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setCompositeOperation(compositeOperation);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetLineWidth(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "setLineWidth");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    float width = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setLineWidth(width);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetLineCap(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "setLineCap");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    String cap = exec->argument(0).toString(exec)->value(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setLineCap(cap);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetLineJoin(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "setLineJoin");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    String join = exec->argument(0).toString(exec)->value(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setLineJoin(join);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetMiterLimit(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "setMiterLimit");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    float limit = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setMiterLimit(limit);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionClearShadow(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "clearShadow");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    impl.clearShadow();
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionFillText(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "fillText");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 3))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    String text = exec->argument(0).toString(exec)->value(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float x = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());

    size_t argsCount = exec->argumentCount();
    if (argsCount <= 3) {
        impl.fillText(text, x, y);
        return JSValue::encode(jsUndefined());
    }

    float maxWidth = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.fillText(text, x, y, maxWidth);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionStrokeText(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "strokeText");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 3))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    String text = exec->argument(0).toString(exec)->value(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float x = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());

    size_t argsCount = exec->argumentCount();
    if (argsCount <= 3) {
        impl.strokeText(text, x, y);
        return JSValue::encode(jsUndefined());
    }

    float maxWidth = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.strokeText(text, x, y, maxWidth);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor1(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "setStrokeColor");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 1))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    String color = exec->argument(0).toString(exec)->value(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());

    size_t argsCount = exec->argumentCount();
    if (argsCount <= 1) {
        impl.setStrokeColor(color);
        return JSValue::encode(jsUndefined());
    }

    float alpha = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setStrokeColor(color, alpha);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor2(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "setStrokeColor");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 1))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float grayLevel = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());

    size_t argsCount = exec->argumentCount();
    if (argsCount <= 1) {
        impl.setStrokeColor(grayLevel);
        return JSValue::encode(jsUndefined());
    }

    float alpha = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(alpha)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    impl.setStrokeColor(grayLevel, alpha);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor3(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "setStrokeColor");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 4))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float r = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float g = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float b = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float a = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setStrokeColor(r, g, b, a);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor4(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "setStrokeColor");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 5))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float c = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float m = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float k = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float a = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setStrokeColor(c, m, y, k, a);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor(ExecState* exec)
{
    size_t argsCount = std::min<size_t>(5, exec->argumentCount());
    JSValue arg0(exec->argument(0));
    if ((argsCount == 1 && (arg0.isUndefinedOrNull() || arg0.isString() || arg0.isObject())) || (argsCount == 2 && (arg0.isUndefinedOrNull() || arg0.isString() || arg0.isObject())))
        return jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor1(exec);
    if (argsCount == 1 || argsCount == 2)
        return jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor2(exec);
    if (argsCount == 4)
        return jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor3(exec);
    if (argsCount == 5)
        return jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor4(exec);
    if (argsCount < 1)
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    return throwVMTypeError(exec);
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetFillColor1(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "setFillColor");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 1))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    String color = exec->argument(0).toString(exec)->value(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());

    size_t argsCount = exec->argumentCount();
    if (argsCount <= 1) {
        impl.setFillColor(color);
        return JSValue::encode(jsUndefined());
    }

    float alpha = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setFillColor(color, alpha);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetFillColor2(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "setFillColor");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 1))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float grayLevel = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());

    size_t argsCount = exec->argumentCount();
    if (argsCount <= 1) {
        impl.setFillColor(grayLevel);
        return JSValue::encode(jsUndefined());
    }

    float alpha = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setFillColor(grayLevel, alpha);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetFillColor3(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "setFillColor");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 4))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float r = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float g = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float b = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float a = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setFillColor(r, g, b, a);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetFillColor4(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "setFillColor");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 5))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float c = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float m = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float k = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float a = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setFillColor(c, m, y, k, a);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetFillColor(ExecState* exec)
{
    size_t argsCount = std::min<size_t>(5, exec->argumentCount());
    JSValue arg0(exec->argument(0));
    if ((argsCount == 1 && (arg0.isUndefinedOrNull() || arg0.isString() || arg0.isObject())) || (argsCount == 2 && (arg0.isUndefinedOrNull() || arg0.isString() || arg0.isObject())))
        return jsCanvasRenderingContext2DPrototypeFunctionSetFillColor1(exec);
    if (argsCount == 1 || argsCount == 2)
        return jsCanvasRenderingContext2DPrototypeFunctionSetFillColor2(exec);
    if (argsCount == 4)
        return jsCanvasRenderingContext2DPrototypeFunctionSetFillColor3(exec);
    if (argsCount == 5)
        return jsCanvasRenderingContext2DPrototypeFunctionSetFillColor4(exec);
    if (argsCount < 1)
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    return throwVMTypeError(exec);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionStrokeRect(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "strokeRect");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 4))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float x = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float width = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float height = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.strokeRect(x, y, width, height);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawImage1(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "drawImage");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 3))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    HTMLImageElement* image = JSHTMLImageElement::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float x = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawImage(image, x, y, ec);
    setDOMException(exec, ec);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawImage2(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "drawImage");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 5))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    HTMLImageElement* image = JSHTMLImageElement::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float x = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float width = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float height = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawImage(image, x, y, width, height, ec);
    setDOMException(exec, ec);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawImage3(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "drawImage");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 9))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    HTMLImageElement* image = JSHTMLImageElement::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float sx = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float sy = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float sw = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float sh = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float dx = exec->argument(5).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float dy = exec->argument(6).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float dw = exec->argument(7).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float dh = exec->argument(8).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh, ec);
    setDOMException(exec, ec);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawImage4(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "drawImage");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 3))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    HTMLCanvasElement* canvas = JSHTMLCanvasElement::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float x = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawImage(canvas, x, y, ec);
    setDOMException(exec, ec);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawImage5(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "drawImage");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 5))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    HTMLCanvasElement* canvas = JSHTMLCanvasElement::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float x = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float width = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float height = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawImage(canvas, x, y, width, height, ec);
    setDOMException(exec, ec);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawImage6(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "drawImage");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 9))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    HTMLCanvasElement* canvas = JSHTMLCanvasElement::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float sx = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float sy = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float sw = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float sh = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float dx = exec->argument(5).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float dy = exec->argument(6).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float dw = exec->argument(7).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float dh = exec->argument(8).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawImage(canvas, sx, sy, sw, sh, dx, dy, dw, dh, ec);
    setDOMException(exec, ec);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawImage7(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "drawImage");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 3))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    HTMLVideoElement* video = JSHTMLVideoElement::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float x = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawImage(video, x, y, ec);
    setDOMException(exec, ec);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawImage8(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "drawImage");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 5))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    HTMLVideoElement* video = JSHTMLVideoElement::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float x = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float width = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float height = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawImage(video, x, y, width, height, ec);
    setDOMException(exec, ec);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawImage9(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "drawImage");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 9))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    HTMLVideoElement* video = JSHTMLVideoElement::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float sx = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float sy = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float sw = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float sh = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float dx = exec->argument(5).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float dy = exec->argument(6).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float dw = exec->argument(7).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float dh = exec->argument(8).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawImage(video, sx, sy, sw, sh, dx, dy, dw, dh, ec);
    setDOMException(exec, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawImage(ExecState* exec)
{
    size_t argsCount = std::min<size_t>(9, exec->argumentCount());
    JSValue arg0(exec->argument(0));
    if ((argsCount == 3 && (arg0.isNull() || (arg0.isObject() && asObject(arg0)->inherits(JSHTMLImageElement::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionDrawImage1(exec);
    if ((argsCount == 5 && (arg0.isNull() || (arg0.isObject() && asObject(arg0)->inherits(JSHTMLImageElement::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionDrawImage2(exec);
    if ((argsCount == 9 && (arg0.isNull() || (arg0.isObject() && asObject(arg0)->inherits(JSHTMLImageElement::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionDrawImage3(exec);
    if ((argsCount == 3 && (arg0.isNull() || (arg0.isObject() && asObject(arg0)->inherits(JSHTMLCanvasElement::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionDrawImage4(exec);
    if ((argsCount == 5 && (arg0.isNull() || (arg0.isObject() && asObject(arg0)->inherits(JSHTMLCanvasElement::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionDrawImage5(exec);
    if ((argsCount == 9 && (arg0.isNull() || (arg0.isObject() && asObject(arg0)->inherits(JSHTMLCanvasElement::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionDrawImage6(exec);
    if ((argsCount == 3 && (arg0.isNull() || (arg0.isObject() && asObject(arg0)->inherits(JSHTMLVideoElement::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionDrawImage7(exec);
    if ((argsCount == 5 && (arg0.isNull() || (arg0.isObject() && asObject(arg0)->inherits(JSHTMLVideoElement::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionDrawImage8(exec);
    if ((argsCount == 9 && (arg0.isNull() || (arg0.isObject() && asObject(arg0)->inherits(JSHTMLVideoElement::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionDrawImage9(exec);
    if (argsCount < 3)
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    return throwVMTypeError(exec);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawImageFromRect(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "drawImageFromRect");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 1))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    HTMLImageElement* image = JSHTMLImageElement::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());

    size_t argsCount = exec->argumentCount();
    if (argsCount <= 1) {
        impl.drawImageFromRect(image);
        return JSValue::encode(jsUndefined());
    }

    float sx = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (argsCount <= 2) {
        impl.drawImageFromRect(image, sx);
        return JSValue::encode(jsUndefined());
    }

    float sy = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (argsCount <= 3) {
        impl.drawImageFromRect(image, sx, sy);
        return JSValue::encode(jsUndefined());
    }

    float sw = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (argsCount <= 4) {
        impl.drawImageFromRect(image, sx, sy, sw);
        return JSValue::encode(jsUndefined());
    }

    float sh = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (argsCount <= 5) {
        impl.drawImageFromRect(image, sx, sy, sw, sh);
        return JSValue::encode(jsUndefined());
    }

    float dx = exec->argument(5).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (argsCount <= 6) {
        impl.drawImageFromRect(image, sx, sy, sw, sh, dx);
        return JSValue::encode(jsUndefined());
    }

    float dy = exec->argument(6).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (argsCount <= 7) {
        impl.drawImageFromRect(image, sx, sy, sw, sh, dx, dy);
        return JSValue::encode(jsUndefined());
    }

    float dw = exec->argument(7).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (argsCount <= 8) {
        impl.drawImageFromRect(image, sx, sy, sw, sh, dx, dy, dw);
        return JSValue::encode(jsUndefined());
    }

    float dh = exec->argument(8).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (argsCount <= 9) {
        impl.drawImageFromRect(image, sx, sy, sw, sh, dx, dy, dw, dh);
        return JSValue::encode(jsUndefined());
    }

    String compositeOperation = exec->argument(9).toString(exec)->value(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawImageFromRect(image, sx, sy, sw, sh, dx, dy, dw, dh, compositeOperation);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetShadow1(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "setShadow");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 3))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float width = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float height = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float blur = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());

    size_t argsCount = exec->argumentCount();
    if (argsCount <= 3) {
        impl.setShadow(width, height, blur);
        return JSValue::encode(jsUndefined());
    }

    String color = exec->argument(3).toString(exec)->value(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (argsCount <= 4) {
        impl.setShadow(width, height, blur, color);
        return JSValue::encode(jsUndefined());
    }

    float alpha = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setShadow(width, height, blur, color, alpha);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetShadow2(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "setShadow");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 4))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float width = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float height = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float blur = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float grayLevel = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());

    size_t argsCount = exec->argumentCount();
    if (argsCount <= 4) {
        impl.setShadow(width, height, blur, grayLevel);
        return JSValue::encode(jsUndefined());
    }

    float alpha = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setShadow(width, height, blur, grayLevel, alpha);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetShadow3(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "setShadow");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 7))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float width = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float height = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float blur = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float r = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float g = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float b = exec->argument(5).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float a = exec->argument(6).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setShadow(width, height, blur, r, g, b, a);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetShadow4(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "setShadow");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 8))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    float width = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(width)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float height = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float blur = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float c = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float m = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float y = exec->argument(5).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float k = exec->argument(6).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float a = exec->argument(7).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setShadow(width, height, blur, c, m, y, k, a);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetShadow(ExecState* exec)
{
    size_t argsCount = std::min<size_t>(8, exec->argumentCount());
    JSValue arg3(exec->argument(3));
    if (argsCount == 3 || (argsCount == 4 && (arg3.isUndefinedOrNull() || arg3.isString() || arg3.isObject())) || (argsCount == 5 && (arg3.isUndefinedOrNull() || arg3.isString() || arg3.isObject())))
        return jsCanvasRenderingContext2DPrototypeFunctionSetShadow1(exec);
    if (argsCount == 4 || argsCount == 5)
        return jsCanvasRenderingContext2DPrototypeFunctionSetShadow2(exec);
    if (argsCount == 7)
        return jsCanvasRenderingContext2DPrototypeFunctionSetShadow3(exec);
    if (argsCount == 8)
        return jsCanvasRenderingContext2DPrototypeFunctionSetShadow4(exec);
    if (argsCount < 3)
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    return throwVMTypeError(exec);
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionPutImageData1(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "putImageData");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 3))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    ImageData* imagedata = JSImageData::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float dx = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(dx)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float dy = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(dy)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    impl.putImageData(imagedata, dx, dy, ec);
    setDOMException(exec, ec);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionPutImageData2(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "putImageData");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 7))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    ImageData* imagedata = JSImageData::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float dx = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(dx)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float dy = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(dy)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float dirtyX = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(dirtyX)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float dirtyY = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(dirtyY)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float dirtyWidth = exec->argument(5).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(dirtyWidth)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float dirtyHeight = exec->argument(6).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(dirtyHeight)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    impl.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight, ec);
    setDOMException(exec, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionPutImageData(ExecState* exec)
{
    size_t argsCount = std::min<size_t>(7, exec->argumentCount());
    JSValue arg0(exec->argument(0));
    if ((argsCount == 3 && (arg0.isNull() || (arg0.isObject() && asObject(arg0)->inherits(JSImageData::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionPutImageData1(exec);
    if ((argsCount == 7 && (arg0.isNull() || (arg0.isObject() && asObject(arg0)->inherits(JSImageData::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionPutImageData2(exec);
    if (argsCount < 3)
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    return throwVMTypeError(exec);
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionWebkitPutImageDataHD1(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "webkitPutImageDataHD");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 3))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    ImageData* imagedata = JSImageData::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float dx = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(dx)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float dy = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(dy)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    impl.webkitPutImageDataHD(imagedata, dx, dy, ec);
    setDOMException(exec, ec);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionWebkitPutImageDataHD2(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "webkitPutImageDataHD");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 7))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    ImageData* imagedata = JSImageData::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    float dx = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(dx)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float dy = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(dy)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float dirtyX = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(dirtyX)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float dirtyY = exec->argument(4).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(dirtyY)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float dirtyWidth = exec->argument(5).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(dirtyWidth)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float dirtyHeight = exec->argument(6).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(dirtyHeight)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    impl.webkitPutImageDataHD(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight, ec);
    setDOMException(exec, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionWebkitPutImageDataHD(ExecState* exec)
{
    size_t argsCount = std::min<size_t>(7, exec->argumentCount());
    JSValue arg0(exec->argument(0));
    if ((argsCount == 3 && (arg0.isNull() || (arg0.isObject() && asObject(arg0)->inherits(JSImageData::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionWebkitPutImageDataHD1(exec);
    if ((argsCount == 7 && (arg0.isNull() || (arg0.isObject() && asObject(arg0)->inherits(JSImageData::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionWebkitPutImageDataHD2(exec);
    if (argsCount < 3)
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    return throwVMTypeError(exec);
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCreatePattern1(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "createPattern");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 2))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    HTMLCanvasElement* canvas = JSHTMLCanvasElement::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    String repetitionType = valueToStringWithNullCheck(exec, exec->argument(1));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl.createPattern(canvas, repetitionType, ec)));

    setDOMException(exec, ec);
    return JSValue::encode(result);
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCreatePattern2(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "createPattern");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 2))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    HTMLImageElement* image = JSHTMLImageElement::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    String repetitionType = valueToStringWithNullCheck(exec, exec->argument(1));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl.createPattern(image, repetitionType, ec)));

    setDOMException(exec, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCreatePattern(ExecState* exec)
{
    size_t argsCount = std::min<size_t>(2, exec->argumentCount());
    JSValue arg0(exec->argument(0));
    if ((argsCount == 2 && (arg0.isNull() || (arg0.isObject() && asObject(arg0)->inherits(JSHTMLCanvasElement::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionCreatePattern1(exec);
    if ((argsCount == 2 && (arg0.isNull() || (arg0.isObject() && asObject(arg0)->inherits(JSHTMLImageElement::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionCreatePattern2(exec);
    if (argsCount < 2)
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    return throwVMTypeError(exec);
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCreateImageData1(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "createImageData");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 1))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    ImageData* imagedata = JSImageData::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl.createImageData(imagedata, ec)));

    setDOMException(exec, ec);
    return JSValue::encode(result);
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCreateImageData2(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "createImageData");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 2))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    float sw = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(sw)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float sh = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(sh)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl.createImageData(sw, sh, ec)));

    setDOMException(exec, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCreateImageData(ExecState* exec)
{
    size_t argsCount = std::min<size_t>(2, exec->argumentCount());
    JSValue arg0(exec->argument(0));
    if ((argsCount == 1 && (arg0.isNull() || (arg0.isObject() && asObject(arg0)->inherits(JSImageData::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionCreateImageData1(exec);
    if (argsCount == 2)
        return jsCanvasRenderingContext2DPrototypeFunctionCreateImageData2(exec);
    if (argsCount < 1)
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    return throwVMTypeError(exec);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionGetImageData(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "getImageData");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 4))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    float sx = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(sx)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float sy = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(sy)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float sw = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(sw)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float sh = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(sh)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl.getImageData(sx, sy, sw, sh, ec)));

    setDOMException(exec, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionWebkitGetImageDataHD(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "webkitGetImageDataHD");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 4))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    ExceptionCode ec = 0;
    float sx = exec->argument(0).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(sx)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float sy = exec->argument(1).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(sy)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float sw = exec->argument(2).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(sw)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    float sh = exec->argument(3).toFloat(exec);
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    if (!std::isfinite(sh)) {
        setDOMException(exec, TypeError);
        return JSValue::encode(jsUndefined());
    }
    JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl.webkitGetImageDataHD(sx, sy, sw, sh, ec)));

    setDOMException(exec, ec);
    return JSValue::encode(result);
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawFocusIfNeeded1(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "drawFocusIfNeeded");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 1))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    Element* element = JSElement::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawFocusIfNeeded(element);
    return JSValue::encode(jsUndefined());
}

static EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawFocusIfNeeded2(ExecState* exec)
{
    JSValue thisValue = exec->thisValue();
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*exec, "CanvasRenderingContext2D", "drawFocusIfNeeded");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->impl();
    if (UNLIKELY(exec->argumentCount() < 2))
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    DOMPath* path = JSDOMPath::toWrapped(exec->argument(0));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    Element* element = JSElement::toWrapped(exec->argument(1));
    if (UNLIKELY(exec->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawFocusIfNeeded(path, element);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawFocusIfNeeded(ExecState* exec)
{
    size_t argsCount = std::min<size_t>(2, exec->argumentCount());
    JSValue arg0(exec->argument(0));
    if ((argsCount == 1 && ((arg0.isObject() && asObject(arg0)->inherits(JSElement::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionDrawFocusIfNeeded1(exec);
    JSValue arg1(exec->argument(1));
    if ((argsCount == 2 && ((arg0.isObject() && asObject(arg0)->inherits(JSDOMPath::info()))) && ((arg1.isObject() && asObject(arg1)->inherits(JSElement::info())))))
        return jsCanvasRenderingContext2DPrototypeFunctionDrawFocusIfNeeded2(exec);
    if (argsCount < 1)
        return throwVMError(exec, createNotEnoughArgumentsError(exec));
    return throwVMTypeError(exec);
}


}
