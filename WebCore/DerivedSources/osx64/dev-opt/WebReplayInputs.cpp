/*
 * Copyright (C) 2014 Apple Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from WebInputs.json
// by the script: JavaScriptCore/replay/scripts/CodeGeneratorReplayInputs.py

#include "config.h"
#include "WebReplayInputs.h"

#if ENABLE(WEB_REPLAY)
#include "MemoizedDOMResult.h"
#include "Page.h"
#include "PlatformKeyboardEvent.h"
#include "PlatformMouseEvent.h"
#include "PlatformWheelEvent.h"
#include "PluginData.h"
#include "ScrollTypes.h"
#include "SerializationMethods.h"
#include <inspector/InspectorValues.h>
#include <replay/NondeterministicInput.h>
#include <wtf/NeverDestroyed.h>

namespace WebCore {
BeginSegmentSentinel::BeginSegmentSentinel()
    : EventLoopInput<BeginSegmentSentinel>()
{
}

BeginSegmentSentinel::~BeginSegmentSentinel()
{
}

DocumentLastModifiedDate::DocumentLastModifiedDate(double fallbackValue)
    : NondeterministicInput<DocumentLastModifiedDate>()
    , m_fallbackValue(fallbackValue)
{
}

DocumentLastModifiedDate::~DocumentLastModifiedDate()
{
}

EndSegmentSentinel::EndSegmentSentinel()
    : EventLoopInput<EndSegmentSentinel>()
{
}

EndSegmentSentinel::~EndSegmentSentinel()
{
}

HandleMouseMove::HandleMouseMove(std::unique_ptr<PlatformMouseEvent> platformEvent, bool scrollbarTargeted)
    : EventLoopInput<HandleMouseMove>()
    , m_platformEvent(WTF::move(platformEvent))
    , m_scrollbarTargeted(scrollbarTargeted)
{
}

HandleMouseMove::~HandleMouseMove()
{
}

HandleMousePress::HandleMousePress(std::unique_ptr<PlatformMouseEvent> platformEvent)
    : EventLoopInput<HandleMousePress>()
    , m_platformEvent(WTF::move(platformEvent))
{
}

HandleMousePress::~HandleMousePress()
{
}

HandleMouseRelease::HandleMouseRelease(std::unique_ptr<PlatformMouseEvent> platformEvent)
    : EventLoopInput<HandleMouseRelease>()
    , m_platformEvent(WTF::move(platformEvent))
{
}

HandleMouseRelease::~HandleMouseRelease()
{
}

HandleKeyPress::HandleKeyPress(std::unique_ptr<PlatformKeyboardEvent> platformEvent)
    : EventLoopInput<HandleKeyPress>()
    , m_platformEvent(WTF::move(platformEvent))
{
}

HandleKeyPress::~HandleKeyPress()
{
}

HandleWheelEvent::HandleWheelEvent(std::unique_ptr<PlatformWheelEvent> platformEvent)
    : EventLoopInput<HandleWheelEvent>()
    , m_platformEvent(WTF::move(platformEvent))
{
}

HandleWheelEvent::~HandleWheelEvent()
{
}

InitialNavigation::InitialNavigation(RefPtr<SecurityOrigin>&& securityOrigin, URL url, String referrer)
    : EventLoopInput<InitialNavigation>()
    , m_securityOrigin(WTF::move(securityOrigin))
    , m_url(url)
    , m_referrer(referrer)
{
}

InitialNavigation::~InitialNavigation()
{
}

FetchPluginData::FetchPluginData(RefPtr<PluginData>&& pluginData)
    : NondeterministicInput<FetchPluginData>()
    , m_pluginData(WTF::move(pluginData))
{
}

FetchPluginData::~FetchPluginData()
{
}

LogicalScrollPage::LogicalScrollPage(ScrollLogicalDirection direction, ScrollGranularity granularity)
    : EventLoopInput<LogicalScrollPage>()
    , m_direction(direction)
    , m_granularity(granularity)
{
}

LogicalScrollPage::~LogicalScrollPage()
{
}

ScrollPage::ScrollPage(ScrollDirection direction, ScrollGranularity granularity)
    : EventLoopInput<ScrollPage>()
    , m_direction(direction)
    , m_granularity(granularity)
{
}

ScrollPage::~ScrollPage()
{
}
} // namespace WebCore

namespace JSC {
const String& InputTraits<WebCore::BeginSegmentSentinel>::type()
{
    static NeverDestroyed<const String> type(ASCIILiteral("BeginSegmentSentinel"));
    return type;
}

void InputTraits<WebCore::BeginSegmentSentinel>::encode(EncodedValue& encodedValue, const WebCore::BeginSegmentSentinel& input)
{
    UNUSED_PARAM(encodedValue);
    UNUSED_PARAM(input);
}

bool InputTraits<WebCore::BeginSegmentSentinel>::decode(EncodedValue& encodedValue, std::unique_ptr<WebCore::BeginSegmentSentinel>& input)
{
    UNUSED_PARAM(encodedValue);
    input = std::make_unique<WebCore::BeginSegmentSentinel>();
    return true;
}

const String& InputTraits<WebCore::DocumentLastModifiedDate>::type()
{
    static NeverDestroyed<const String> type(ASCIILiteral("DocumentLastModifiedDate"));
    return type;
}

void InputTraits<WebCore::DocumentLastModifiedDate>::encode(EncodedValue& encodedValue, const WebCore::DocumentLastModifiedDate& input)
{
    encodedValue.put<double>(ASCIILiteral("fallbackValue"), input.fallbackValue());
}

bool InputTraits<WebCore::DocumentLastModifiedDate>::decode(EncodedValue& encodedValue, std::unique_ptr<WebCore::DocumentLastModifiedDate>& input)
{
    double fallbackValue;
    if (!encodedValue.get<double>(ASCIILiteral("fallbackValue"), fallbackValue))
        return false;

    input = std::make_unique<WebCore::DocumentLastModifiedDate>(fallbackValue);
    return true;
}

const String& InputTraits<WebCore::EndSegmentSentinel>::type()
{
    static NeverDestroyed<const String> type(ASCIILiteral("EndSegmentSentinel"));
    return type;
}

void InputTraits<WebCore::EndSegmentSentinel>::encode(EncodedValue& encodedValue, const WebCore::EndSegmentSentinel& input)
{
    UNUSED_PARAM(encodedValue);
    UNUSED_PARAM(input);
}

bool InputTraits<WebCore::EndSegmentSentinel>::decode(EncodedValue& encodedValue, std::unique_ptr<WebCore::EndSegmentSentinel>& input)
{
    UNUSED_PARAM(encodedValue);
    input = std::make_unique<WebCore::EndSegmentSentinel>();
    return true;
}

const String& InputTraits<WebCore::HandleMouseMove>::type()
{
    static NeverDestroyed<const String> type(ASCIILiteral("HandleMouseMove"));
    return type;
}

void InputTraits<WebCore::HandleMouseMove>::encode(EncodedValue& encodedValue, const WebCore::HandleMouseMove& input)
{
    encodedValue.put<WebCore::PlatformMouseEvent>(ASCIILiteral("platformEvent"), input.platformEvent());
    encodedValue.put<bool>(ASCIILiteral("scrollbarTargeted"), input.scrollbarTargeted());
}

bool InputTraits<WebCore::HandleMouseMove>::decode(EncodedValue& encodedValue, std::unique_ptr<WebCore::HandleMouseMove>& input)
{
    std::unique_ptr<WebCore::PlatformMouseEvent> platformEvent;
    if (!encodedValue.get<WebCore::PlatformMouseEvent>(ASCIILiteral("platformEvent"), platformEvent))
        return false;

    bool scrollbarTargeted;
    if (!encodedValue.get<bool>(ASCIILiteral("scrollbarTargeted"), scrollbarTargeted))
        return false;

    input = std::make_unique<WebCore::HandleMouseMove>(WTF::move(platformEvent), scrollbarTargeted);
    return true;
}

const String& InputTraits<WebCore::HandleMousePress>::type()
{
    static NeverDestroyed<const String> type(ASCIILiteral("HandleMousePress"));
    return type;
}

void InputTraits<WebCore::HandleMousePress>::encode(EncodedValue& encodedValue, const WebCore::HandleMousePress& input)
{
    encodedValue.put<WebCore::PlatformMouseEvent>(ASCIILiteral("platformEvent"), input.platformEvent());
}

bool InputTraits<WebCore::HandleMousePress>::decode(EncodedValue& encodedValue, std::unique_ptr<WebCore::HandleMousePress>& input)
{
    std::unique_ptr<WebCore::PlatformMouseEvent> platformEvent;
    if (!encodedValue.get<WebCore::PlatformMouseEvent>(ASCIILiteral("platformEvent"), platformEvent))
        return false;

    input = std::make_unique<WebCore::HandleMousePress>(WTF::move(platformEvent));
    return true;
}

const String& InputTraits<WebCore::HandleMouseRelease>::type()
{
    static NeverDestroyed<const String> type(ASCIILiteral("HandleMouseRelease"));
    return type;
}

void InputTraits<WebCore::HandleMouseRelease>::encode(EncodedValue& encodedValue, const WebCore::HandleMouseRelease& input)
{
    encodedValue.put<WebCore::PlatformMouseEvent>(ASCIILiteral("platformEvent"), input.platformEvent());
}

bool InputTraits<WebCore::HandleMouseRelease>::decode(EncodedValue& encodedValue, std::unique_ptr<WebCore::HandleMouseRelease>& input)
{
    std::unique_ptr<WebCore::PlatformMouseEvent> platformEvent;
    if (!encodedValue.get<WebCore::PlatformMouseEvent>(ASCIILiteral("platformEvent"), platformEvent))
        return false;

    input = std::make_unique<WebCore::HandleMouseRelease>(WTF::move(platformEvent));
    return true;
}

const String& InputTraits<WebCore::HandleKeyPress>::type()
{
    static NeverDestroyed<const String> type(ASCIILiteral("HandleKeyPress"));
    return type;
}

void InputTraits<WebCore::HandleKeyPress>::encode(EncodedValue& encodedValue, const WebCore::HandleKeyPress& input)
{
    encodedValue.put<WebCore::PlatformKeyboardEvent>(ASCIILiteral("platformEvent"), input.platformEvent());
}

bool InputTraits<WebCore::HandleKeyPress>::decode(EncodedValue& encodedValue, std::unique_ptr<WebCore::HandleKeyPress>& input)
{
    std::unique_ptr<WebCore::PlatformKeyboardEvent> platformEvent;
    if (!encodedValue.get<WebCore::PlatformKeyboardEvent>(ASCIILiteral("platformEvent"), platformEvent))
        return false;

    input = std::make_unique<WebCore::HandleKeyPress>(WTF::move(platformEvent));
    return true;
}

const String& InputTraits<WebCore::HandleWheelEvent>::type()
{
    static NeverDestroyed<const String> type(ASCIILiteral("HandleWheelEvent"));
    return type;
}

void InputTraits<WebCore::HandleWheelEvent>::encode(EncodedValue& encodedValue, const WebCore::HandleWheelEvent& input)
{
    encodedValue.put<WebCore::PlatformWheelEvent>(ASCIILiteral("platformEvent"), input.platformEvent());
}

bool InputTraits<WebCore::HandleWheelEvent>::decode(EncodedValue& encodedValue, std::unique_ptr<WebCore::HandleWheelEvent>& input)
{
    std::unique_ptr<WebCore::PlatformWheelEvent> platformEvent;
    if (!encodedValue.get<WebCore::PlatformWheelEvent>(ASCIILiteral("platformEvent"), platformEvent))
        return false;

    input = std::make_unique<WebCore::HandleWheelEvent>(WTF::move(platformEvent));
    return true;
}

const String& InputTraits<WebCore::InitialNavigation>::type()
{
    static NeverDestroyed<const String> type(ASCIILiteral("InitialNavigation"));
    return type;
}

void InputTraits<WebCore::InitialNavigation>::encode(EncodedValue& encodedValue, const WebCore::InitialNavigation& input)
{
    encodedValue.put<WebCore::SecurityOrigin>(ASCIILiteral("securityOrigin"), input.securityOrigin());
    encodedValue.put<WebCore::URL>(ASCIILiteral("url"), input.url());
    encodedValue.put<WTF::String>(ASCIILiteral("referrer"), input.referrer());
}

bool InputTraits<WebCore::InitialNavigation>::decode(EncodedValue& encodedValue, std::unique_ptr<WebCore::InitialNavigation>& input)
{
    RefPtr<WebCore::SecurityOrigin> securityOrigin;
    if (!encodedValue.get<WebCore::SecurityOrigin>(ASCIILiteral("securityOrigin"), securityOrigin))
        return false;

    WebCore::URL url;
    if (!encodedValue.get<WebCore::URL>(ASCIILiteral("url"), url))
        return false;

    WTF::String referrer;
    if (!encodedValue.get<WTF::String>(ASCIILiteral("referrer"), referrer))
        return false;

    input = std::make_unique<WebCore::InitialNavigation>(WTF::move(securityOrigin), url, referrer);
    return true;
}

const String& InputTraits<WebCore::FetchPluginData>::type()
{
    static NeverDestroyed<const String> type(ASCIILiteral("FetchPluginData"));
    return type;
}

void InputTraits<WebCore::FetchPluginData>::encode(EncodedValue& encodedValue, const WebCore::FetchPluginData& input)
{
    encodedValue.put<WebCore::PluginData>(ASCIILiteral("pluginData"), input.pluginData());
}

bool InputTraits<WebCore::FetchPluginData>::decode(EncodedValue& encodedValue, std::unique_ptr<WebCore::FetchPluginData>& input)
{
    RefPtr<WebCore::PluginData> pluginData;
    if (!encodedValue.get<WebCore::PluginData>(ASCIILiteral("pluginData"), pluginData))
        return false;

    input = std::make_unique<WebCore::FetchPluginData>(WTF::move(pluginData));
    return true;
}

const String& InputTraits<WebCore::LogicalScrollPage>::type()
{
    static NeverDestroyed<const String> type(ASCIILiteral("LogicalScrollPage"));
    return type;
}

void InputTraits<WebCore::LogicalScrollPage>::encode(EncodedValue& encodedValue, const WebCore::LogicalScrollPage& input)
{
    encodedValue.put<WebCore::ScrollLogicalDirection>(ASCIILiteral("direction"), input.direction());
    encodedValue.put<WebCore::ScrollGranularity>(ASCIILiteral("granularity"), input.granularity());
}

bool InputTraits<WebCore::LogicalScrollPage>::decode(EncodedValue& encodedValue, std::unique_ptr<WebCore::LogicalScrollPage>& input)
{
    WebCore::ScrollLogicalDirection direction;
    if (!encodedValue.get<WebCore::ScrollLogicalDirection>(ASCIILiteral("direction"), direction))
        return false;

    WebCore::ScrollGranularity granularity;
    if (!encodedValue.get<WebCore::ScrollGranularity>(ASCIILiteral("granularity"), granularity))
        return false;

    input = std::make_unique<WebCore::LogicalScrollPage>(direction, granularity);
    return true;
}

const String& InputTraits<WebCore::ScrollPage>::type()
{
    static NeverDestroyed<const String> type(ASCIILiteral("ScrollPage"));
    return type;
}

void InputTraits<WebCore::ScrollPage>::encode(EncodedValue& encodedValue, const WebCore::ScrollPage& input)
{
    encodedValue.put<WebCore::ScrollDirection>(ASCIILiteral("direction"), input.direction());
    encodedValue.put<WebCore::ScrollGranularity>(ASCIILiteral("granularity"), input.granularity());
}

bool InputTraits<WebCore::ScrollPage>::decode(EncodedValue& encodedValue, std::unique_ptr<WebCore::ScrollPage>& input)
{
    WebCore::ScrollDirection direction;
    if (!encodedValue.get<WebCore::ScrollDirection>(ASCIILiteral("direction"), direction))
        return false;

    WebCore::ScrollGranularity granularity;
    if (!encodedValue.get<WebCore::ScrollGranularity>(ASCIILiteral("granularity"), granularity))
        return false;

    input = std::make_unique<WebCore::ScrollPage>(direction, granularity);
    return true;
}
EncodedValue EncodingTraits<WebCore::EncodedCType>::encodeValue(const WebCore::EncodedCType& enumValue)
{
    switch (enumValue) {
    case WebCore::EncodedCType::Boolean: return EncodedValue::createString("Boolean");
    case WebCore::EncodedCType::Int: return EncodedValue::createString("Int");
    case WebCore::EncodedCType::String: return EncodedValue::createString("String");
    case WebCore::EncodedCType::Unsigned: return EncodedValue::createString("Unsigned");
    default: ASSERT_NOT_REACHED(); return EncodedValue::createString("Error!");
    }
}

bool EncodingTraits<WebCore::EncodedCType>::decodeValue(EncodedValue& encodedValue, WebCore::EncodedCType& enumValue)
{
    String enumString = encodedValue.convertTo<String>();
    if (enumString == "Boolean") {
        enumValue = WebCore::EncodedCType::Boolean;
        return true;
    }
    if (enumString == "Int") {
        enumValue = WebCore::EncodedCType::Int;
        return true;
    }
    if (enumString == "String") {
        enumValue = WebCore::EncodedCType::String;
        return true;
    }
    if (enumString == "Unsigned") {
        enumValue = WebCore::EncodedCType::Unsigned;
        return true;
    }
    return false;
}

EncodedValue EncodingTraits<WebCore::MouseButton>::encodeValue(const WebCore::MouseButton& enumValue)
{
    EncodedValue encodedValue = EncodedValue::createArray();
    if (enumValue & WebCore::NoButton) {
        encodedValue.append<String>(ASCIILiteral("NoButton"));
        if (enumValue == WebCore::NoButton)
            return encodedValue;
    }
    if (enumValue & WebCore::LeftButton) {
        encodedValue.append<String>(ASCIILiteral("LeftButton"));
        if (enumValue == WebCore::LeftButton)
            return encodedValue;
    }
    if (enumValue & WebCore::MiddleButton) {
        encodedValue.append<String>(ASCIILiteral("MiddleButton"));
        if (enumValue == WebCore::MiddleButton)
            return encodedValue;
    }
    if (enumValue & WebCore::RightButton) {
        encodedValue.append<String>(ASCIILiteral("RightButton"));
        if (enumValue == WebCore::RightButton)
            return encodedValue;
    }
    return encodedValue;
}

bool EncodingTraits<WebCore::MouseButton>::decodeValue(EncodedValue& encodedValue, WebCore::MouseButton& enumValue)
{
    Vector<String> enumStrings;
    if (!EncodingTraits<Vector<String>>::decodeValue(encodedValue, enumStrings))
        return false;

    for (const String& enumString : enumStrings) {
        if (enumString == "NoButton")
            enumValue = static_cast<WebCore::MouseButton>(enumValue | WebCore::NoButton);
        else if (enumString == "LeftButton")
            enumValue = static_cast<WebCore::MouseButton>(enumValue | WebCore::LeftButton);
        else if (enumString == "MiddleButton")
            enumValue = static_cast<WebCore::MouseButton>(enumValue | WebCore::MiddleButton);
        else if (enumString == "RightButton")
            enumValue = static_cast<WebCore::MouseButton>(enumValue | WebCore::RightButton);
    }

    return true;
}

EncodedValue EncodingTraits<WebCore::PlatformEvent::Modifiers>::encodeValue(const WebCore::PlatformEvent::Modifiers& enumValue)
{
    EncodedValue encodedValue = EncodedValue::createArray();
    if (enumValue & WebCore::PlatformEvent::AltKey) {
        encodedValue.append<String>(ASCIILiteral("AltKey"));
        if (enumValue == WebCore::PlatformEvent::AltKey)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformEvent::CtrlKey) {
        encodedValue.append<String>(ASCIILiteral("CtrlKey"));
        if (enumValue == WebCore::PlatformEvent::CtrlKey)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformEvent::MetaKey) {
        encodedValue.append<String>(ASCIILiteral("MetaKey"));
        if (enumValue == WebCore::PlatformEvent::MetaKey)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformEvent::ShiftKey) {
        encodedValue.append<String>(ASCIILiteral("ShiftKey"));
        if (enumValue == WebCore::PlatformEvent::ShiftKey)
            return encodedValue;
    }
    return encodedValue;
}

bool EncodingTraits<WebCore::PlatformEvent::Modifiers>::decodeValue(EncodedValue& encodedValue, WebCore::PlatformEvent::Modifiers& enumValue)
{
    Vector<String> enumStrings;
    if (!EncodingTraits<Vector<String>>::decodeValue(encodedValue, enumStrings))
        return false;

    for (const String& enumString : enumStrings) {
        if (enumString == "AltKey")
            enumValue = static_cast<WebCore::PlatformEvent::Modifiers>(enumValue | WebCore::PlatformEvent::AltKey);
        else if (enumString == "CtrlKey")
            enumValue = static_cast<WebCore::PlatformEvent::Modifiers>(enumValue | WebCore::PlatformEvent::CtrlKey);
        else if (enumString == "MetaKey")
            enumValue = static_cast<WebCore::PlatformEvent::Modifiers>(enumValue | WebCore::PlatformEvent::MetaKey);
        else if (enumString == "ShiftKey")
            enumValue = static_cast<WebCore::PlatformEvent::Modifiers>(enumValue | WebCore::PlatformEvent::ShiftKey);
    }

    return true;
}

EncodedValue EncodingTraits<WebCore::PlatformEvent::Type>::encodeValue(const WebCore::PlatformEvent::Type& enumValue)
{
    EncodedValue encodedValue = EncodedValue::createArray();
    if (enumValue & WebCore::PlatformEvent::NoType) {
        encodedValue.append<String>(ASCIILiteral("NoType"));
        if (enumValue == WebCore::PlatformEvent::NoType)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformEvent::KeyDown) {
        encodedValue.append<String>(ASCIILiteral("KeyDown"));
        if (enumValue == WebCore::PlatformEvent::KeyDown)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformEvent::KeyUp) {
        encodedValue.append<String>(ASCIILiteral("KeyUp"));
        if (enumValue == WebCore::PlatformEvent::KeyUp)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformEvent::RawKeyDown) {
        encodedValue.append<String>(ASCIILiteral("RawKeyDown"));
        if (enumValue == WebCore::PlatformEvent::RawKeyDown)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformEvent::Char) {
        encodedValue.append<String>(ASCIILiteral("Char"));
        if (enumValue == WebCore::PlatformEvent::Char)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformEvent::MouseMoved) {
        encodedValue.append<String>(ASCIILiteral("MouseMoved"));
        if (enumValue == WebCore::PlatformEvent::MouseMoved)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformEvent::MousePressed) {
        encodedValue.append<String>(ASCIILiteral("MousePressed"));
        if (enumValue == WebCore::PlatformEvent::MousePressed)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformEvent::MouseReleased) {
        encodedValue.append<String>(ASCIILiteral("MouseReleased"));
        if (enumValue == WebCore::PlatformEvent::MouseReleased)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformEvent::MouseScroll) {
        encodedValue.append<String>(ASCIILiteral("MouseScroll"));
        if (enumValue == WebCore::PlatformEvent::MouseScroll)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformEvent::Wheel) {
        encodedValue.append<String>(ASCIILiteral("Wheel"));
        if (enumValue == WebCore::PlatformEvent::Wheel)
            return encodedValue;
    }
#if ENABLE(TOUCH_EVENTS)
    if (enumValue & WebCore::PlatformEvent::TouchStart) {
        encodedValue.append<String>(ASCIILiteral("TouchStart"));
        if (enumValue == WebCore::PlatformEvent::TouchStart)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformEvent::TouchMove) {
        encodedValue.append<String>(ASCIILiteral("TouchMove"));
        if (enumValue == WebCore::PlatformEvent::TouchMove)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformEvent::TouchEnd) {
        encodedValue.append<String>(ASCIILiteral("TouchEnd"));
        if (enumValue == WebCore::PlatformEvent::TouchEnd)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformEvent::TouchCancel) {
        encodedValue.append<String>(ASCIILiteral("TouchCancel"));
        if (enumValue == WebCore::PlatformEvent::TouchCancel)
            return encodedValue;
    }
#endif // ENABLE(TOUCH_EVENTS)
    return encodedValue;
}

bool EncodingTraits<WebCore::PlatformEvent::Type>::decodeValue(EncodedValue& encodedValue, WebCore::PlatformEvent::Type& enumValue)
{
    Vector<String> enumStrings;
    if (!EncodingTraits<Vector<String>>::decodeValue(encodedValue, enumStrings))
        return false;

    for (const String& enumString : enumStrings) {
        if (enumString == "NoType")
            enumValue = static_cast<WebCore::PlatformEvent::Type>(enumValue | WebCore::PlatformEvent::NoType);
        else if (enumString == "KeyDown")
            enumValue = static_cast<WebCore::PlatformEvent::Type>(enumValue | WebCore::PlatformEvent::KeyDown);
        else if (enumString == "KeyUp")
            enumValue = static_cast<WebCore::PlatformEvent::Type>(enumValue | WebCore::PlatformEvent::KeyUp);
        else if (enumString == "RawKeyDown")
            enumValue = static_cast<WebCore::PlatformEvent::Type>(enumValue | WebCore::PlatformEvent::RawKeyDown);
        else if (enumString == "Char")
            enumValue = static_cast<WebCore::PlatformEvent::Type>(enumValue | WebCore::PlatformEvent::Char);
        else if (enumString == "MouseMoved")
            enumValue = static_cast<WebCore::PlatformEvent::Type>(enumValue | WebCore::PlatformEvent::MouseMoved);
        else if (enumString == "MousePressed")
            enumValue = static_cast<WebCore::PlatformEvent::Type>(enumValue | WebCore::PlatformEvent::MousePressed);
        else if (enumString == "MouseReleased")
            enumValue = static_cast<WebCore::PlatformEvent::Type>(enumValue | WebCore::PlatformEvent::MouseReleased);
        else if (enumString == "MouseScroll")
            enumValue = static_cast<WebCore::PlatformEvent::Type>(enumValue | WebCore::PlatformEvent::MouseScroll);
        else if (enumString == "Wheel")
            enumValue = static_cast<WebCore::PlatformEvent::Type>(enumValue | WebCore::PlatformEvent::Wheel);
#if ENABLE(TOUCH_EVENTS)
        if (enumString == "TouchStart")
            enumValue = static_cast<WebCore::PlatformEvent::Type>(enumValue | WebCore::PlatformEvent::TouchStart);
        else if (enumString == "TouchMove")
            enumValue = static_cast<WebCore::PlatformEvent::Type>(enumValue | WebCore::PlatformEvent::TouchMove);
        else if (enumString == "TouchEnd")
            enumValue = static_cast<WebCore::PlatformEvent::Type>(enumValue | WebCore::PlatformEvent::TouchEnd);
        else if (enumString == "TouchCancel")
            enumValue = static_cast<WebCore::PlatformEvent::Type>(enumValue | WebCore::PlatformEvent::TouchCancel);
#endif // ENABLE(TOUCH_EVENTS)
    }

    return true;
}

EncodedValue EncodingTraits<WebCore::PlatformWheelEventGranularity>::encodeValue(const WebCore::PlatformWheelEventGranularity& enumValue)
{
    EncodedValue encodedValue = EncodedValue::createArray();
    if (enumValue & WebCore::ScrollByPageWheelEvent) {
        encodedValue.append<String>(ASCIILiteral("ScrollByPageWheelEvent"));
        if (enumValue == WebCore::ScrollByPageWheelEvent)
            return encodedValue;
    }
    if (enumValue & WebCore::ScrollByPixelWheelEvent) {
        encodedValue.append<String>(ASCIILiteral("ScrollByPixelWheelEvent"));
        if (enumValue == WebCore::ScrollByPixelWheelEvent)
            return encodedValue;
    }
    return encodedValue;
}

bool EncodingTraits<WebCore::PlatformWheelEventGranularity>::decodeValue(EncodedValue& encodedValue, WebCore::PlatformWheelEventGranularity& enumValue)
{
    Vector<String> enumStrings;
    if (!EncodingTraits<Vector<String>>::decodeValue(encodedValue, enumStrings))
        return false;

    for (const String& enumString : enumStrings) {
        if (enumString == "ScrollByPageWheelEvent")
            enumValue = static_cast<WebCore::PlatformWheelEventGranularity>(enumValue | WebCore::ScrollByPageWheelEvent);
        else if (enumString == "ScrollByPixelWheelEvent")
            enumValue = static_cast<WebCore::PlatformWheelEventGranularity>(enumValue | WebCore::ScrollByPixelWheelEvent);
    }

    return true;
}

#if PLATFORM(COCOA)
EncodedValue EncodingTraits<WebCore::PlatformWheelEventPhase>::encodeValue(const WebCore::PlatformWheelEventPhase& enumValue)
{
    EncodedValue encodedValue = EncodedValue::createArray();
    if (enumValue & WebCore::PlatformWheelEventPhaseNone) {
        encodedValue.append<String>(ASCIILiteral("PlatformWheelEventPhaseNone"));
        if (enumValue == WebCore::PlatformWheelEventPhaseNone)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformWheelEventPhaseBegan) {
        encodedValue.append<String>(ASCIILiteral("PlatformWheelEventPhaseBegan"));
        if (enumValue == WebCore::PlatformWheelEventPhaseBegan)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformWheelEventPhaseStationary) {
        encodedValue.append<String>(ASCIILiteral("PlatformWheelEventPhaseStationary"));
        if (enumValue == WebCore::PlatformWheelEventPhaseStationary)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformWheelEventPhaseChanged) {
        encodedValue.append<String>(ASCIILiteral("PlatformWheelEventPhaseChanged"));
        if (enumValue == WebCore::PlatformWheelEventPhaseChanged)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformWheelEventPhaseEnded) {
        encodedValue.append<String>(ASCIILiteral("PlatformWheelEventPhaseEnded"));
        if (enumValue == WebCore::PlatformWheelEventPhaseEnded)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformWheelEventPhaseCancelled) {
        encodedValue.append<String>(ASCIILiteral("PlatformWheelEventPhaseCancelled"));
        if (enumValue == WebCore::PlatformWheelEventPhaseCancelled)
            return encodedValue;
    }
    if (enumValue & WebCore::PlatformWheelEventPhaseMayBegin) {
        encodedValue.append<String>(ASCIILiteral("PlatformWheelEventPhaseMayBegin"));
        if (enumValue == WebCore::PlatformWheelEventPhaseMayBegin)
            return encodedValue;
    }
    return encodedValue;
}

bool EncodingTraits<WebCore::PlatformWheelEventPhase>::decodeValue(EncodedValue& encodedValue, WebCore::PlatformWheelEventPhase& enumValue)
{
    Vector<String> enumStrings;
    if (!EncodingTraits<Vector<String>>::decodeValue(encodedValue, enumStrings))
        return false;

    for (const String& enumString : enumStrings) {
        if (enumString == "PlatformWheelEventPhaseNone")
            enumValue = static_cast<WebCore::PlatformWheelEventPhase>(enumValue | WebCore::PlatformWheelEventPhaseNone);
        else if (enumString == "PlatformWheelEventPhaseBegan")
            enumValue = static_cast<WebCore::PlatformWheelEventPhase>(enumValue | WebCore::PlatformWheelEventPhaseBegan);
        else if (enumString == "PlatformWheelEventPhaseStationary")
            enumValue = static_cast<WebCore::PlatformWheelEventPhase>(enumValue | WebCore::PlatformWheelEventPhaseStationary);
        else if (enumString == "PlatformWheelEventPhaseChanged")
            enumValue = static_cast<WebCore::PlatformWheelEventPhase>(enumValue | WebCore::PlatformWheelEventPhaseChanged);
        else if (enumString == "PlatformWheelEventPhaseEnded")
            enumValue = static_cast<WebCore::PlatformWheelEventPhase>(enumValue | WebCore::PlatformWheelEventPhaseEnded);
        else if (enumString == "PlatformWheelEventPhaseCancelled")
            enumValue = static_cast<WebCore::PlatformWheelEventPhase>(enumValue | WebCore::PlatformWheelEventPhaseCancelled);
        else if (enumString == "PlatformWheelEventPhaseMayBegin")
            enumValue = static_cast<WebCore::PlatformWheelEventPhase>(enumValue | WebCore::PlatformWheelEventPhaseMayBegin);
    }

    return true;
}
#endif // PLATFORM(COCOA)

EncodedValue EncodingTraits<WebCore::PluginLoadClientPolicy>::encodeValue(const WebCore::PluginLoadClientPolicy& enumValue)
{
    EncodedValue encodedValue = EncodedValue::createArray();
    if (enumValue & WebCore::PluginLoadClientPolicyUndefined) {
        encodedValue.append<String>(ASCIILiteral("PluginLoadClientPolicyUndefined"));
        if (enumValue == WebCore::PluginLoadClientPolicyUndefined)
            return encodedValue;
    }
    if (enumValue & WebCore::PluginLoadClientPolicyBlock) {
        encodedValue.append<String>(ASCIILiteral("PluginLoadClientPolicyBlock"));
        if (enumValue == WebCore::PluginLoadClientPolicyBlock)
            return encodedValue;
    }
    if (enumValue & WebCore::PluginLoadClientPolicyAsk) {
        encodedValue.append<String>(ASCIILiteral("PluginLoadClientPolicyAsk"));
        if (enumValue == WebCore::PluginLoadClientPolicyAsk)
            return encodedValue;
    }
    if (enumValue & WebCore::PluginLoadClientPolicyAllow) {
        encodedValue.append<String>(ASCIILiteral("PluginLoadClientPolicyAllow"));
        if (enumValue == WebCore::PluginLoadClientPolicyAllow)
            return encodedValue;
    }
    if (enumValue & WebCore::PluginLoadClientPolicyAllowAlways) {
        encodedValue.append<String>(ASCIILiteral("PluginLoadClientPolicyAllowAlways"));
        if (enumValue == WebCore::PluginLoadClientPolicyAllowAlways)
            return encodedValue;
    }
    return encodedValue;
}

bool EncodingTraits<WebCore::PluginLoadClientPolicy>::decodeValue(EncodedValue& encodedValue, WebCore::PluginLoadClientPolicy& enumValue)
{
    Vector<String> enumStrings;
    if (!EncodingTraits<Vector<String>>::decodeValue(encodedValue, enumStrings))
        return false;

    for (const String& enumString : enumStrings) {
        if (enumString == "PluginLoadClientPolicyUndefined")
            enumValue = static_cast<WebCore::PluginLoadClientPolicy>(enumValue | WebCore::PluginLoadClientPolicyUndefined);
        else if (enumString == "PluginLoadClientPolicyBlock")
            enumValue = static_cast<WebCore::PluginLoadClientPolicy>(enumValue | WebCore::PluginLoadClientPolicyBlock);
        else if (enumString == "PluginLoadClientPolicyAsk")
            enumValue = static_cast<WebCore::PluginLoadClientPolicy>(enumValue | WebCore::PluginLoadClientPolicyAsk);
        else if (enumString == "PluginLoadClientPolicyAllow")
            enumValue = static_cast<WebCore::PluginLoadClientPolicy>(enumValue | WebCore::PluginLoadClientPolicyAllow);
        else if (enumString == "PluginLoadClientPolicyAllowAlways")
            enumValue = static_cast<WebCore::PluginLoadClientPolicy>(enumValue | WebCore::PluginLoadClientPolicyAllowAlways);
    }

    return true;
}

EncodedValue EncodingTraits<WebCore::ScrollDirection>::encodeValue(const WebCore::ScrollDirection& enumValue)
{
    EncodedValue encodedValue = EncodedValue::createArray();
    if (enumValue & WebCore::ScrollUp) {
        encodedValue.append<String>(ASCIILiteral("ScrollUp"));
        if (enumValue == WebCore::ScrollUp)
            return encodedValue;
    }
    if (enumValue & WebCore::ScrollDown) {
        encodedValue.append<String>(ASCIILiteral("ScrollDown"));
        if (enumValue == WebCore::ScrollDown)
            return encodedValue;
    }
    if (enumValue & WebCore::ScrollLeft) {
        encodedValue.append<String>(ASCIILiteral("ScrollLeft"));
        if (enumValue == WebCore::ScrollLeft)
            return encodedValue;
    }
    if (enumValue & WebCore::ScrollRight) {
        encodedValue.append<String>(ASCIILiteral("ScrollRight"));
        if (enumValue == WebCore::ScrollRight)
            return encodedValue;
    }
    return encodedValue;
}

bool EncodingTraits<WebCore::ScrollDirection>::decodeValue(EncodedValue& encodedValue, WebCore::ScrollDirection& enumValue)
{
    Vector<String> enumStrings;
    if (!EncodingTraits<Vector<String>>::decodeValue(encodedValue, enumStrings))
        return false;

    for (const String& enumString : enumStrings) {
        if (enumString == "ScrollUp")
            enumValue = static_cast<WebCore::ScrollDirection>(enumValue | WebCore::ScrollUp);
        else if (enumString == "ScrollDown")
            enumValue = static_cast<WebCore::ScrollDirection>(enumValue | WebCore::ScrollDown);
        else if (enumString == "ScrollLeft")
            enumValue = static_cast<WebCore::ScrollDirection>(enumValue | WebCore::ScrollLeft);
        else if (enumString == "ScrollRight")
            enumValue = static_cast<WebCore::ScrollDirection>(enumValue | WebCore::ScrollRight);
    }

    return true;
}

EncodedValue EncodingTraits<WebCore::ScrollGranularity>::encodeValue(const WebCore::ScrollGranularity& enumValue)
{
    EncodedValue encodedValue = EncodedValue::createArray();
    if (enumValue & WebCore::ScrollByLine) {
        encodedValue.append<String>(ASCIILiteral("ScrollByLine"));
        if (enumValue == WebCore::ScrollByLine)
            return encodedValue;
    }
    if (enumValue & WebCore::ScrollByPage) {
        encodedValue.append<String>(ASCIILiteral("ScrollByPage"));
        if (enumValue == WebCore::ScrollByPage)
            return encodedValue;
    }
    if (enumValue & WebCore::ScrollByDocument) {
        encodedValue.append<String>(ASCIILiteral("ScrollByDocument"));
        if (enumValue == WebCore::ScrollByDocument)
            return encodedValue;
    }
    if (enumValue & WebCore::ScrollByPixel) {
        encodedValue.append<String>(ASCIILiteral("ScrollByPixel"));
        if (enumValue == WebCore::ScrollByPixel)
            return encodedValue;
    }
    if (enumValue & WebCore::ScrollByPrecisePixel) {
        encodedValue.append<String>(ASCIILiteral("ScrollByPrecisePixel"));
        if (enumValue == WebCore::ScrollByPrecisePixel)
            return encodedValue;
    }
    return encodedValue;
}

bool EncodingTraits<WebCore::ScrollGranularity>::decodeValue(EncodedValue& encodedValue, WebCore::ScrollGranularity& enumValue)
{
    Vector<String> enumStrings;
    if (!EncodingTraits<Vector<String>>::decodeValue(encodedValue, enumStrings))
        return false;

    for (const String& enumString : enumStrings) {
        if (enumString == "ScrollByLine")
            enumValue = static_cast<WebCore::ScrollGranularity>(enumValue | WebCore::ScrollByLine);
        else if (enumString == "ScrollByPage")
            enumValue = static_cast<WebCore::ScrollGranularity>(enumValue | WebCore::ScrollByPage);
        else if (enumString == "ScrollByDocument")
            enumValue = static_cast<WebCore::ScrollGranularity>(enumValue | WebCore::ScrollByDocument);
        else if (enumString == "ScrollByPixel")
            enumValue = static_cast<WebCore::ScrollGranularity>(enumValue | WebCore::ScrollByPixel);
        else if (enumString == "ScrollByPrecisePixel")
            enumValue = static_cast<WebCore::ScrollGranularity>(enumValue | WebCore::ScrollByPrecisePixel);
    }

    return true;
}

EncodedValue EncodingTraits<WebCore::ScrollLogicalDirection>::encodeValue(const WebCore::ScrollLogicalDirection& enumValue)
{
    EncodedValue encodedValue = EncodedValue::createArray();
    if (enumValue & WebCore::ScrollBlockDirectionBackward) {
        encodedValue.append<String>(ASCIILiteral("ScrollBlockDirectionBackward"));
        if (enumValue == WebCore::ScrollBlockDirectionBackward)
            return encodedValue;
    }
    if (enumValue & WebCore::ScrollBlockDirectionForward) {
        encodedValue.append<String>(ASCIILiteral("ScrollBlockDirectionForward"));
        if (enumValue == WebCore::ScrollBlockDirectionForward)
            return encodedValue;
    }
    if (enumValue & WebCore::ScrollInlineDirectionBackward) {
        encodedValue.append<String>(ASCIILiteral("ScrollInlineDirectionBackward"));
        if (enumValue == WebCore::ScrollInlineDirectionBackward)
            return encodedValue;
    }
    if (enumValue & WebCore::ScrollInlineDirectionForward) {
        encodedValue.append<String>(ASCIILiteral("ScrollInlineDirectionForward"));
        if (enumValue == WebCore::ScrollInlineDirectionForward)
            return encodedValue;
    }
    return encodedValue;
}

bool EncodingTraits<WebCore::ScrollLogicalDirection>::decodeValue(EncodedValue& encodedValue, WebCore::ScrollLogicalDirection& enumValue)
{
    Vector<String> enumStrings;
    if (!EncodingTraits<Vector<String>>::decodeValue(encodedValue, enumStrings))
        return false;

    for (const String& enumString : enumStrings) {
        if (enumString == "ScrollBlockDirectionBackward")
            enumValue = static_cast<WebCore::ScrollLogicalDirection>(enumValue | WebCore::ScrollBlockDirectionBackward);
        else if (enumString == "ScrollBlockDirectionForward")
            enumValue = static_cast<WebCore::ScrollLogicalDirection>(enumValue | WebCore::ScrollBlockDirectionForward);
        else if (enumString == "ScrollInlineDirectionBackward")
            enumValue = static_cast<WebCore::ScrollLogicalDirection>(enumValue | WebCore::ScrollInlineDirectionBackward);
        else if (enumString == "ScrollInlineDirectionForward")
            enumValue = static_cast<WebCore::ScrollLogicalDirection>(enumValue | WebCore::ScrollInlineDirectionForward);
    }

    return true;
}
} // namespace JSC

#endif // ENABLE(WEB_REPLAY)
